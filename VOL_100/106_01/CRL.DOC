				crl.doc

	Copyright (C) 1980, M J Maney

	last revised 9/6/80 21:55


	This file shall attempt to explain the use of the macros defined in
	the "crl.lib" library file.

	The purpose of the crl.lib file is to make it less painful to write
	function modules in assembler that can be linked to the code
	generated by the BDS C compiler. There are several reasons for
	wishing to do this, the primary one being the sometimes grossly
	inefficent code sequences that the compiler generates. This is not
	due so much to the compiler's simple-mindedness as to the limited
	capabilities of the 8080 instruction set. A clever programmer can
	produce much more compact code than ANY compiler for the 8080
	(or probably most any of the early microprocessors), and in some
	cases the difference can be simply astounding. Thus, we shall at
	times desire to replace a function originally coded in C with a
	carefully optimized one written in assembler. And thus the driving
	force behind the package herein described.

	There is currently one minor nuisance involved in utilizing the
	macros...the hex file is NOT properly loaded by the CP/M load
	utility, so good old ddt's services are required (still). But at
	least all you have to do is use ddt to load the hex file. Once
	the image is in memory, all that is required is to "save" the
	image as a ".crl" file.

	For example, to load the functions in strfun.asm into the crl
	format file (named, of course, strfun.crl), the procedure is:

    1)	assemble strfun
    2)	use ddt to load the hex file produced. I've been clearing the
	background to zero first, which helped during debugging of the
	crl macros, but isn't really needed.
    3)	note what address ddt reports, this is the top of the memory
	image that must be saved.
    4)	exit ddt, remembering the address
    5)	save the memory image using the built-in "save" utility and
	the address that you (hopefully) remembered. The number of
	"pages" that must be saved are

		n = ceiling((address - base of TPA) / 0x100)

	where ceiling(x) is the smallest integer equal or larger than x.
	For standard CP/M, this is simply the "100's" digit of the
	address....at least for the sample files I sent.
    6)	That's it

	If this sounds like a lot of work, let me reassure you...its
	easier to do than to explain. I could execute the whole sequence
	in far less time than its taken me to write all this, and maybe
	in less time than it takes to read this (unless you're a graduate
	of the Evelyn Wood system).
