;=============================================================================
;=============================================================================
;
;                Macro Library for Turbo Pascal v5.5
;
;   Writen by Clark A. Calkins,
;             C. C. Software
;             1907 Alvarado Ave.
;             Walnut Creek, CA 94596
;
;             circa September 1990
;
;   This file may be freely copied and used for non-commercial purposes.
;   Intended for use with the Masterful Disassembler (MD86) version 2.3 or
;   later. This file should be compiled with MD86MAC v1.3 or later. No
;   compiler error or warning messages should be generated.
;
;   There are no known coding errors in these macros but no guarantees are
;   implied.
;
;=============================================================================
;=============================================================================
;
;=============================================================================
;   String processing macros.
;=============================================================================
;
;   =====>>> String write macros.
;
;
;   Macro to write out the first string constant w/o format.
;
macroname = WrtStrCnstF
  size    = 10
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$bf,$00,$00,$0e,$57,$31,$c0,$50,$9a
  flags   = call
  comment = Write first string constant.
;
;   Verify call destination.
;
  argument
    rbyte = 14
    type = faraddress
    name = WrtItem
  endargument
;
;   Get address if FCB.
;
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
;
;   Get address of string constant.
;
  argument
    rbyte = 6
    type  = address
    segment = cs
  endargument
endmacro
;
;   Macro to write out a string constant w/o format.
;
macroname = WrtStrCnst
  size    = 7
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$ff,$ff
  compare = $bf,$00,$00,$0e,$57,$31,$c0,$50,$9a
  flags   = call
  comment = Write string constant.
;
;   Verify call destination.
;
  argument
    rbyte = 9
    type = faraddress
    name = WrtItem
  endargument
;
;   Get address of string constant.
;
  argument
    rbyte = 1
    type  = address
    segment = cs
  endargument
endmacro
;
;   Macro to write out the first string variable w/o format.
;
macroname = WrtStrVarF
  size    = 10
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$bf,$00,$00,$1e,$57,$31,$c0,$50,$9a
  flags   = call
  comment = Write first string var.
;
;   Verify call destination.
;
  argument
    rbyte = 14
    type = faraddress
    name = WrtItem
  endargument
;
;   Get address if FCB.
;
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
;
;   Get address of string constant.
;
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to write out another string variable w/o format.
;
macroname = WrtStrVar
  size    = 7
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$31,$c0,$50,$9a
  flags   = call
  comment = Write string var.
;
;   Verify call destination.
;
  argument
    rbyte = 9
    type = faraddress
    name = WrtItem
  endargument
;
;   Get address of string constant.
;
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to check the results of previous I/O.
;
macroname = CheckIO_Result
  size    = 2
  mask    = $ff,$00,$00,$00,$00,$ff
  compare = $9a,$00,$00,$00,$00,$9a
  flags   = call
  argument
    rbyte = 1
    type  = faraddress
    name  = IO_end
  endargument
  argument
    rbyte = 6
    type  = faraddress
    name  = Check_IO
  endargument
endmacro
;
;   Macro to end a line and check I/O result.
;
macroname = EndLine_CheckIO
  size    = 2
  mask    = $ff,$00,$00,$00,$00,$ff
  compare = $9a,$00,$00,$00,$00,$9a
  flags   = call
  comment = End line and check IOResult.
  argument
    rbyte = 1
    type  = faraddress
    name  = Line_end
  endargument
  argument
    rbyte = 6
    type  = faraddress
    name  = Check_IO
  endargument
endmacro
;
;   =====>>> Macros for reading in string variables.
;
macroname = ReadLine_CheckIO
  size    = 2
  mask    = $ff,$00,$00,$00,$00,$ff
  compare = $9a,$00,$00,$00,$00,$9a
  flags   = call
  comment = Read to EOL, check IOResult.
  argument
    rbyte = 1
    type  = faraddress
    name  = Get_EOL
  endargument
  argument
    rbyte = 6
    type  = faraddress
    name  = Check_IO
  endargument
endmacro
;
;   Read a string as the first item in a list.
;
macroname = ReadStrF
  size    = 9
  mask    = $ff,$00,$00,$ff,$ff
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57
  compare = $bf,$00,$00,$1e,$57,$b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "read str (file, var, len)."
  argument
    rbyte = 15
    type  = faraddress
    name  = RdStrItm
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 11
    type  = word
  endargument
endmacro
;
;   Read the next item as a string.
;
macroname = ReadStr
  size    = 6
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "read string (var, len)."
 argument
    rbyte = 10
    type  = faraddress
    name  = RdStrItm
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = word
  endargument
endmacro
;
;=============================================================================
;   =====>>> String assignment and COPY macros.
;=============================================================================
;
;
;   Macro to assign a simple string constant to a string variable.
;
;     --> StrConstAssign source, destination, max_length
;
macroname = StrConstAssign
  size    = 9
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff
  mask    = $ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$0e,$57,$bf,$00,$00,$1e,$57
  compare = $b8,$00,$00,$50,$9a
  flags   = call,perm
;
;   This pseudo argument is used to verify that the call instruction has the
;   desired destination address. Its name (StrMove) must already be in place.
;
  argument
    rbyte = 15
    type  = faraddress
    name  = StrMove
  endargument
;
;   First real argument is the address of the source string constant. This is a
;   CS: relative offset too.
;
  argument
    rbyte = 1
    type  = address
    segment = cs
  endargument
;
;   Second argument is the address of the destination string variable. This is
;   a DS: relative offset (we must declare this or CS {from above} will be
;   used).
;
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
 ;
 ;   The last argument is the max length of the destination string. This will
 ;   be used to truncate the string if necessary.
 ;
  argument
    rbyte = 11
    type  = word
  endargument
endmacro
;
;   Macro to concatinate a string constant to the back of a string variable.
;
;     --> ConcatStrConst temp_level,source_str, str_constant
;
macroname = ConcatStrConst
  size    = 12
  mask    = $ff,$ff,$ff,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff,$00,$00,$00,$00
  compare = $8d,$be,$00,$00,$16,$57,$bf,$00,$00,$1e,$57,$9a,$00,$00,$00,$00
  mask    = $ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$0e,$57,$9a
  flags   = call,perm
;
;   Verify destination address of all calls.
;
  argument
    rbyte = 12
    type  = faraddress
    name  = StrStore
  endargument
  argument
    rbyte = 22
    type  = faraddress
    name  = StrAdd
  endargument
;
;   First argument is the level indicator (which temp variable to use).
;
  argument
    rbyte = 2
    type  = word
  endargument
;
;   Next is the address of the source string.
;
  argument
    rbyte = 7
    type  = address
    segment = ds
  endargument
;
;   Now the address of the string constant (CS: relative).
;
  argument
    rbyte = 17
    type  = address
    segment = cs
  endargument
endmacro
;
;   Macro to add a string variable to the back of a string constant.
;
macroname = ConcatStrVar
  size    = 12
  mask    = $ff,$ff,$ff,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff
  compare = $8d,$be,$00,$00,$16,$57,$bf,$00,$00,$0e,$57,$9a
  mask    = $00,$00,$00,$00,$ff,$00,$00,$ff,$ff,$ff
  compare = $00,$00,$00,$00,$bf,$00,$00,$1e,$57,$9a
  flags   = call,perm
;
;   Verify destinations of both calls.
;
  argument
    rbyte = 12
    type  = faraddress
    name  = StrStore
  endargument
  argument
    rbyte = 22
    type  = faraddress
    name  = StrAdd
  endargument
;
;   First argument is the level indicator (which temp variable to use).
;
  argument
    rbyte = 2
    type  = word
  endargument
;
;   Next argument is address of string constant.
;
  argument
    rbyte = 7
    type  = address
    segment = cs
  endargument
;
;   Now the address of the string variable to add.
;
  argument
    rbyte = 17
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to use COPY to get a substring from a simple string variable.
;
;      --> CopyStrVar Source_string,start_pos,num_chars
;   where start_pos and num_chars are integer constants.
;
macroname = CopyStrVar
  size    = 8
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$b8,$00,$00,$50,$b8,$00,$00,$50,$9a
  comment = "copy(ARG1,ARG2,ARG3)"
  flags   = call,perm
;
;   Verify the proper call address.
;
  argument
    rbyte = 14
    type  = faraddress
    name  = StrCopy
  endargument
;
;   Setup the address of the source string variable.
;
  argument
    rbyte = 1
    type  = address
  endargument
;
;   The next argument represents the first character position.
;
  argument
    rbyte = 6
    type  = word
  endargument
;
;   Lastly, include the number of characters to copy.
;
  argument
    rbyte = 10
    type  = word
  endargument
endmacro
;
;   Similar for a slightly different calling sequence. This has the num_chars
;   as a variable.
;
macroname = CopyStrVar
  size    = 8
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff
  compare = $bf,$00,$00,$1e,$57,$b8,$00,$00,$50,$ff,$36,$00,$00,$9a
  comment = "copy(ARG1,ARG2,ARG3)"
  flags   = call,perm
;
  argument
    rbyte = 14
    type  = faraddress
    name  = StrCopy
  endargument
;
  argument
    rbyte = 1
    type  = address
  endargument
;
  argument
    rbyte = 6
    type  = word
  endargument
;
  argument
    rbyte = 11
    type  = address
  endargument
endmacro
;
;   Similar for a slightly different calling sequence. This has the start_pos
;   as a variable.
;
macroname = CopyStrVar
  size    = 8
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$00,$00,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$ff,$36,$00,$00,$b8,$00,$00,$50,$9a
  comment = "copy(ARG1,ARG2,ARG3)"
  flags   = call,perm
;
  argument
    rbyte = 14
    type  = faraddress
    name  = StrCopy
  endargument
;
  argument
    rbyte = 1
    type  = address
  endargument
;
  argument
    rbyte = 7
    type  = address
  endargument
;
  argument
    rbyte = 10
    type  = word
  endargument
endmacro
;
;   Similar for a slightly different calling sequence. This has the start_pos
;   and num_chars as variables.
;
macroname = CopyStrVar
  size    = 8
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $bf,$00,$00,$1e,$57,$ff,$36,$00,$00,$ff,$36,$00,$00,$9a
  comment = "copy(ARG1,ARG2,ARG3)"
  flags   = call
;
  argument
    rbyte = 14
    type  = faraddress
    name  = StrCopy
  endargument
;
  argument
    rbyte = 1
    type  = address
  endargument
;
  argument
    rbyte = 7
    type  = address
  endargument
;
  argument
    rbyte = 11
    type  = address
  endargument
endmacro
;
;   Macro to get a substring from a string function using COPY.
;
;     --> Copy first_char,num_chars
;
macroname = Copy
  size    = 5
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff,$ff
  compare = $b8,$00,$00,$50,$b8,$00,$00,$50,$9a
  flags   = call,perm
;
;   Verify destination of call.
;
  argument
    rbyte = 9
    type  = faraddress
    name  = StrCopy
  endargument
;
;   Get first character position of interest.
;
  argument
    rbyte = 1
    type  = word
  endargument
;
;   Get number of characters to extract.
;
  argument
    rbyte = 5
    type  = word
  endargument
endmacro
;
;   Macro to push the address of a temporary string variable to the stack.
;   Various other functions will use what ever is on the stack.
;
;     --> PushTempStrAddr temp_level
;
macroname = PushTempStrAddr
  size    = 4
  mask    = $ff,$ff,$ff,$00,$ff,$ff
  compare = $8d,$be,$00,$00,$16,$57
  flags   = perm
;
;   First argument is the level indicator (which temp variable to use).
;
  argument
    rbyte = 2
    type  = word
  endargument
endmacro
;
;   Macro to store the temp string into a user variable.
;
;     --> StoreTempStr destination, max_length
;
macroname = StoreTempStr
  size    = 6
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$b8,$00,$00,$50,$9a
  flags   = call,perm
;
;   Verify proper call address.
;
  argument
    rbyte = 10
    type  = faraddress
    name  = StrMove
  endargument
;
;   The first argument is the address of the string variable to load.
;
  argument
    rbyte = 1
    type  = address
  endargument
;
;   Now describe the max number of characters that the above variable can
;   accept.
;
  argument
    rbyte = 6
    type  = word
  endargument
endmacro
;
;   Macro to load a string variable from a temporary result.
;
macroname = LoadStr
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$9a
  flags   = call
;
;   Verify proper call destination.
;
  argument
    rbyte = 6
    type  = faraddress
    name  = StrStore
  endargument
;
;  Address of variable to receive the data (DS relative).
;
  argument
    rbyte = 1
    type  = address
  endargument
endmacro
;
;   Macro to store away a string whose address is already on the stack. The
;   max string length is the one argument here.
;
macroname = StoreStr
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $b8,$00,$00,$50,$9a
  flags   = perm
  comment = "store string, ARG1=max_len"
  argument
    rbyte = 5
    type  = faraddress
    name  = StrMove
  endargument
  argument
    rbyte = 1
    type  = word
  endargument
endmacro
;
;   Macro to add a string constant to a string variable. The address of the
;   variable is already on the stack.
;
;     --> AddStrConst constant
;
macroname = AddStrConst
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$0e,$57,$9a
  flags   = call
;
;   Verify proper destination address.
;
  argument
    rbyte = 6
    type  = faraddress
    name  = StrAdd
  endargument
;
;   Get address of string constant (in the CS:).
;
  argument
    rbyte = 1
    type  = address
    segment = cs
  endargument
endmacro
;
;=============================================================================
;   Long and short integer I/O macros.
;=============================================================================
;
;   Write a short integer (16 bits) without any formatting. With and without
;   a file id.
;
macroname = WriteIntF
  size    = 11
  mask    = $ff,$00,$00,$ff,$ff
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57
  compare = $a1,$00,$00,$99,$52,$50,$31,$c0,$50,$9a
  flags   = call
  comment = "write_int(file, var)."
  argument
    rbyte = 15
    type  = faraddress
    name  = WrtDblWd
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
macroname = WriteInt
  size    = 8
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$ff,$ff,$ff
  compare = $a1,$00,$00,$99,$52,$50,$31,$c0,$50,$9a
  flags   = call
  comment = "write_int(var)."
  argument
    rbyte = 10
    type  = faraddress
    name  = WrtDblWd
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   Write a short integer (16 bits) with formatting. With and without
;   a file id.
;
macroname = WriteIntF
  size    = 10
  mask    = $ff,$00,$00,$ff,$ff
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57
  compare = $a1,$00,$00,$99,$52,$50,$b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "fwrite_int(file, var, format)."
  argument
    rbyte = 16
    type  = faraddress
    name  = WrtDblWd
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 12
    type  = word
  endargument
endmacro
;
macroname = WriteInt
  size    = 7
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $a1,$00,$00,$99,$52,$50,$b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "fwrite_int(var, format)."
  argument
    rbyte = 11
    type  = faraddress
    name  = WrtDblWd
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 7
    type  = word
  endargument
endmacro
;
;   Write a long integer (32 bits) without any formatting. With and without
;   a file id.
;
macroname = WriteLongF
  size    = 13
  mask    = $ff,$00,$00,$ff,$ff
  mask    = $ff,$ff,$00,$00,$ff,$ff,$00,$00,$ff,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57
  compare = $ff,$36,$00,$00,$ff,$36,$00,$00,$31,$c0,$50,$9a
  flags   = call
  comment = "write_long(file, var)."
  argument
    rbyte = 17
    type  = faraddress
    name  = WrtDblWd
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 11
    type  = address
    segment = ds
  endargument
endmacro
;
macroname = WriteLong
  size    = 10
  mask    = $ff,$ff,$00,$00,$ff,$ff,$00,$00,$ff,$ff,$ff,$ff
  compare = $ff,$36,$00,$00,$ff,$36,$00,$00,$31,$c0,$50,$9a
  flags   = call
  comment = "write_long(var)."
  argument
    rbyte = 12
    type  = faraddress
    name  = WrtDblWd
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;   Write a long integer (32 bits) with formatting. With and without
;   a file id.
;
macroname = WriteLongF
  size    = 12
  mask    = $ff,$00,$00,$ff,$ff
  mask    = $ff,$ff,$00,$00,$ff,$ff,$00,$00,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57
  compare = $ff,$36,$00,$00,$ff,$36,$00,$00,$b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "write_long(file, var, format)."
  argument
    rbyte = 18
    type  = faraddress
    name  = WrtDblWd
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 11
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 14
    type  = word
  endargument
endmacro
;
macroname = WriteLong
  size    = 10
  mask    = $ff,$ff,$00,$00,$ff,$ff,$00,$00,$ff,$00,$00,$ff,$ff
  compare = $ff,$36,$00,$00,$ff,$36,$00,$00,$b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "write_long(var, format)."
  argument
    rbyte = 13
    type  = faraddress
    name  = WrtDblWd
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 9
    type  = word
  endargument
endmacro
;
;   Read in a long integer (32 bits) with file id.
;
macroname = RdLongF
  size    = 9
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$00,$00,$ff,$00,$00
  mask    = $ff,$ff
  compare = $bf,$00,$00,$1e,$57,$9a,$00,$00,$00,$00,$a3,$00,$00
  compare = $89,$16
  flags   = call
  comment = Read_long(file, var).
  argument
    rbyte = 6
    type  = faraddress
    name  = RdDblWrd
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 11
    type  = address
    segment = ds
  endargument
endmacro
;
macroname = ReadIntF
  size    = 5
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$00,$00,$ff,$00,$00
  compare = $bf,$00,$00,$1e,$57,$9a,$00,$00,$00,$00,$a3,$00,$00
  flags   = call
  comment = Read_integer(file, var).
  argument
    rbyte = 6
    type  = faraddress
    name  = RdDblWrd
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 11
    type  = address
    segment = ds
  endargument
endmacro
;
;   Read in a long integer (32 bits) without file id.
;
macroname = RdLong
  size    = 6
  mask    = $ff,$00,$00,$00,$00,$ff,$00,$00
  mask    = $ff,$ff
  compare = $9a,$00,$00,$00,$00,$a3,$00,$00
  compare = $89,$16
  flags   = call
  comment = Read_long(var).
  argument
    rbyte = 1
    type  = faraddress
    name  = RdDblWrd
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
macroname = ReadInt
  size    = 2
  mask    = $ff,$00,$00,$00,$00,$ff,$00,$00
  compare = $9a,$00,$00,$00,$00,$a3,$00,$00
  flags   = call
  comment = Read_integer(var).
  argument
    rbyte = 1
    type  = faraddress
    name  = RdDblWrd
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;=============================================================================
;   Macros used to assign file names. This is a string constant as in:
;   ASSIGN(MYFILE,'MYNAME');
;=============================================================================
;
;   The following two macros are for text file assignments.
;
macroname = Assign_t
  size    = 7
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$bf,$00,$00,$0e,$57,$9a
  flags   = call
  comment = "assign text_file, str_const"
  argument
    rbyte = 11
    type  = faraddress
    name  = Txt_asgn
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = address
    segment = cs
  endargument
endmacro
;
;   Same as above except that the file name is specified by a variable rather
;   than a constant. Variables are in the data segment.
;
macroname = Assign_t
  size    = 7
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$bf,$00,$00,$1e,$57,$9a
  flags   = call
  comment = "assign text_file, str_var"
  argument
    rbyte = 11
    type  = faraddress
    name  = Txt_asgn
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;   These two are for binary file assignments.
;
macroname = Assign_b
  size    = 7
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$bf,$00,$00,$0e,$57,$9a
  flags   = call
  comment = "assign binary_file, str_const"
  argument
    rbyte = 11
    type  = faraddress
    name  = Bin_asgn
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = address
    segment = cs
  endargument
endmacro
;
;   Same as above except that the file name is specified by a variable rather
;   than a constant. Variables are in the data segment.
;
macroname = Assign_b
  size    = 7
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$bf,$00,$00,$1e,$57,$9a
  flags   = call
  comment = "assign binary_file, str_var"
  argument
    rbyte = 11
    type  = faraddress
    name  = Bin_asgn
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macros to open files. RESET opens them for reading while REWRITE opens
;   them for writing. As in:
;
;   RESET(myfile);
;   REWRITE(myfile);
;
;   The following two macros is used for text files.
;
macroname = Reset_t
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$9a
  flags   = call
  comment = reset text_file
  argument
    rbyte = 6
    type  = faraddress
    name  = TxtReset
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   Same as above for rewrite().
;
macroname = Rewrit_t
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$9a
  flags   = call
  comment = rewrite text_file
  argument
    rbyte = 6
    type  = faraddress
    name  = TxtWrite
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   These two macros are similar to the above except that they are used with
;   binary (rather than text) files.
;
macroname = Reset_b
  size    = 6
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "reset binary_file, rec_size"
  argument
    rbyte = 10
    type  = faraddress
    name  = BinReset
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = word
  endargument
endmacro
;
macroname = Rewrite_b
  size    = 6
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57,$b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "rewrite binary_file, rec_size"
  argument
    rbyte = 10
    type  = faraddress
    name  = BinWrite
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = word
  endargument
endmacro
;
;============================================================================
;   Macros for the CRT unit.
;============================================================================
;
;   Macros for the GOTOXY(x,y) procedure. Arguments (x and y) can be either
;   byte constants or variables.
;
;   First the form with 2 byte constant arguments.
;
macroname = GotoXY
  size    = 5
  mask    = $ff,$00,$ff,$ff,$00,$ff,$ff
  compare = $b0,$00,$50,$b0,$00,$50,$9a
  flags   = call
  comment = "gotoxy(ARG1,ARG2)"
  argument
    rbyte = 7
    type  = faraddress
    name  = GotoXYp
  endargument
  argument
    rbyte = 1
    type  = byte
  endargument
  argument
    rbyte = 4
    type  = byte
  endargument
endmacro
;
;   Now the form with the first argument a variable and the second a constant.
;
macroname = GotoXY
  size    = 5
  mask    = $ff,$00,$00,$ff,$ff,$00,$ff,$ff
  compare = $a0,$00,$00,$50,$b0,$00,$50,$9a
  flags   = call
  comment = "gotoxy(ARG1,ARG2)"
  argument
    rbyte = 8
    type  = faraddress
    name  = GotoXYp
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = byte
  endargument
endmacro
;
;   Now same but second argument is a variable.
;
macroname = GotoXY
  size    = 5
  mask    = $ff,$00,$ff,$ff,$00,$00,$ff,$ff
  compare = $b0,$00,$50,$a0,$00,$00,$50,$9a
  flags   = call
  comment = "gotoxy(ARG1,ARG2)"
  argument
    rbyte = 8
    type  = faraddress
    name  = GotoXYp
  endargument
  argument
    rbyte = 1
    type  = byte
  endargument
  argument
    rbyte = 4
    type  = address
    segment = ds
  endargument
endmacro
;
;   Now with both arguments variables.
;
macroname = GotoXY
  size    = 5
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff,$ff
  compare = $a0,$00,$00,$50,$a0,$00,$00,$50,$9a
  flags   = call
  comment = "gotoxy(ARG1,ARG2)"
  argument
    rbyte = 9
    type  = faraddress
    name  = GotoXYp
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro for the delay procedure. The argument may be either an integer
;   constant or variable.
;
macroname = Delay
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = "delay(ms)"
  argument
    rbyte = 5
    type  = faraddress
    name  = Delay_p
  endargument
  argument
    rbyte = 1
    type  = word
  endargument
endmacro
;
macroname = Delay
  size    = 3
  mask    = $ff,$ff,$00,$00,$ff
  compare = $ff,$36,$00,$00,$9a
  flags   = call
  comment = "delay(ms)"
  argument
    rbyte = 5
    type  = faraddress
    name  = Delay_p
  endargument
  argument
    rbyte = 2
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to get the key pressed status.
;
macroname = KeyPressed
  size    = 2
  mask    = $ff,$00,$00,$00,$00,$ff
  compare = $9a,$00,$00,$00,$00,$a2
  flags   = call
  comment = ARG1=keypressed()
  argument
    rbyte = 1
    type  = faraddress
    name  = KeyPrest
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to test key pressed status.
;
macroname = IfNoKey
  size    = 4
  mask    = $ff,$00,$00,$00,$00,$ff,$ff,$ff
  compare = $9a,$00,$00,$00,$00,$08,$c0,$74
  flags   = call
  comment = "if not KeyPressed then goto ARG"
  argument
    rbyte = 1
    type  = faraddress
    name  = KeyPrest
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
;   Macro to set the sound at the speeker. The first form uses an integer
;   constant as the frequency indicator.
;
macroname = SetSound
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = set sound pitch to ARG1.
  argument
    rbyte = 5
    type  = faraddress
    name  = Sound
  endargument
  argument
    rbyte = 1
    type  = word
  endargument
endmacro
;
;   Above but using a variable rather than a constant.
;
macroname = SetSound
  size    = 3
  mask    = $ff,$ff,$00,$00,$ff
  compare = $ff,$36,$00,$00,$9a
  flags   = call
  comment = set sound pitch to ARG1.
  argument
    rbyte = 5
    type  = faraddress
    name  = Sound
  endargument
  argument
    rbyte = 2
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macros to set the background color. First uses a constant color number.
;
macroname = TextBackground
  size    = 3
  mask    = $ff,$00,$ff,$ff
  compare = $b0,$00,$50,$9a
  flags   = call
  comment = set background color to ARG1
  argument
    rbyte = 4
    type  = faraddress
    name  = TxtBkg
  endargument
  argument
    rbyte = 1
    type  = byte
  endargument
endmacro
;
;   This one uses a byte variable as the color number.
;
macroname = TextBackground
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $a0,$00,$00,$50,$9a
  flags   = call
  comment = set background color to ARG1
  argument
    rbyte = 5
    type  = faraddress
    name  = TxtBkg
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macros to set the foreground color. First uses a constant color number.
;
macroname = TextColor
  size    = 3
  mask    = $ff,$00,$ff,$ff
  compare = $b0,$00,$50,$9a
  flags   = call
  comment = set foreground color to ARG1
  argument
    rbyte = 4
    type  = faraddress
    name  = TxtColor
  endargument
  argument
    rbyte = 1
    type  = byte
  endargument
endmacro
;
;   This one uses a byte variable as the color number.
;
macroname = TextColor
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $a0,$00,$00,$50,$9a
  flags   = call
  comment = set foreground color to ARG1
  argument
    rbyte = 5
    type  = faraddress
    name  = TxtColor
  endargument
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to read a key and store result in a byte variable.
;
macroname = GetKey
  size    = 2
  mask    = $ff,$00,$00,$00,$00,$ff
  compare = $9a,$00,$00,$00,$00,$a2
  flags   = call
  comment = ARG:=ReadKey;
  argument
    rbyte = 1
    type  = faraddress
    name  = ReadKey
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to test a keystroke against a character constant.
;
macroname = TestKey
  size    = 3
  mask    = $ff,$00,$00,$00,$00,$ff,$00,$ff
  compare = $9a,$00,$00,$00,$00,$3c,$00,$75
  flags   = call
  comment = if ReadKey<>ARG1 then goto ARG2
  argument
    rbyte = 1
    type  = faraddress
    name  = ReadKey
  endargument
  argument
    rbyte = 6
    type  = character
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
;   Macro to set the text mode using an integer constant.
;
macroname = TextMode
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $b8,$00,$00,$50,$9a
  flags   = call,perm
  comment = set text mode to ARG1
  argument
    rbyte = 5
    type  = faraddress
    name  = TxtMode
  endargument
  argument
    rbyte = 1
    type  = word
  endargument
endmacro
;
;   Same ass above except using an integer variable as the argument.
;
macroname = TextMode
  size    = 3
  mask    = $ff,$ff,$00,$00,$ff
  compare = $ff,$36,$00,$00,$9a
  flags   = call
  comment = set text mode to ARG1
  argument
    rbyte = 5
    type  = faraddress
    name  = TxtMode
  endargument
  argument
    rbyte = 2
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macros to determine the current 'X' location on the screen. The first one
;   stuffs the result into an integer variable.
;
macroname = WhereX
  size    = 4
  mask    = $ff,$00,$00,$00,$00,$ff,$ff,$ff
  compare = $9a,$00,$00,$00,$00,$30,$e4,$a3
  flags   = call
  comment = int ARG1:=current 'x' pos
  argument
    rbyte = 1
    type  = faraddress
    name  = Where_X
  endargument
  argument
    rbyte = 8
    type  = address
    segment = ds
  endargument
endmacro
;
;   This macro will stuff the result into a byte variable.
;
macroname = WhereX
  size    = 2
  mask    = $ff,$00,$00,$00,$00,$ff
  compare = $9a,$00,$00,$00,$00,$a2
  flags   = call
  comment = byte ARG1:=current 'x' pos
  argument
    rbyte = 1
    type  = faraddress
    name  = Where_X
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macros to determine the current 'Y' location on the screen. The first one
;   stuffs the result into an integer variable.
;
macroname = WhereY
  size    = 4
  mask    = $ff,$00,$00,$00,$00,$ff,$ff,$ff
  compare = $9a,$00,$00,$00,$00,$30,$e4,$a3
  flags   = call
  comment = int ARG1:=current 'y' pos
  argument
    rbyte = 1
    type  = faraddress
    name  = Where_Y
  endargument
  argument
    rbyte = 8
    type  = address
    segment = ds
  endargument
endmacro
;
;   This macro will stuff the result into a byte variable.
;
macroname = WhereY
  size    = 2
  mask    = $ff,$00,$00,$00,$00,$ff
  compare = $9a,$00,$00,$00,$00,$a2
  flags   = call
  comment = byte ARG1:=current 'y' pos
  argument
    rbyte = 1
    type  = faraddress
    name  = Where_Y
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;=============================================================================
;   These macros must be last. They should be used only if one of the above,
;   more general, macros does not fit. These are less dependent on the
;   compiler being used.
;=============================================================================
;
;   Macros to test integer variables for zero or not zero and jump if true.
;
macroname = IFZERO
  size    = 4
  mask    = $ff,$ff,$00,$00,$ff,$ff,$00
  compare = $80,$3e,$00,$00,$00,$74,$00
  comment = if ARG1=0 then goto ARG2
  argument
    rbyte = 2
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = nearaddress
  endargument
endmacro
;
macroname = IFNZ
  size    = 4
  mask    = $ff,$ff,$00,$00,$ff,$ff,$00
  compare = $80,$3e,$00,$00,$00,$75,$00
  comment = if ARG1<>0 then goto ARG2
  argument
    rbyte = 2
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = nearaddress
  endargument
endmacro
;
;   Macro to test an integer to see if it equals a particular constant or not.
;
macroname = IFEQ
  size    = 3
  mask    = $ff,$00,$00,$ff,$00,$00,$ff
  compare = $a1,$00,$00,$3d,$00,$00,$74
  flags   = perm
  comment = if ARG1 = ARG2 then goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 4
    type  = word
  endargument
  argument
    rbyte = 7
    type  = nearaddress
  endargument
endmacro
;
;   Macro to test an integer to see if it does not equal a particular constant.
;
macroname = IFNEQ
  size    = 3
  mask    = $ff,$00,$00,$ff,$00,$00,$ff
  compare = $a1,$00,$00,$3d,$00,$00,$75
  flags   = perm
  comment = if ARG1 <> ARG2 then goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 4
    type  = word
  endargument
  argument
    rbyte = 7
    type  = nearaddress
  endargument
endmacro
;
;   Macro for an integer function tests.
;
;   if funct() <= 0 then goto ...
;
macroname = IFLEZ
  size    = 4
  mask    = $ff,$00,$00,$00,$00,$ff,$ff,$ff
  compare = $9a,$00,$00,$00,$00,$09,$c0,$7e
  comment = if ARG1() <= 0 then goto ARG2
  argument
    rbyte = 1
    type  = faraddress
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
;   if funct() < 0 then goto ...
;
macroname = IFLTZ
  size    = 4
  mask    = $ff,$00,$00,$00,$00,$ff,$ff,$ff
  compare = $9a,$00,$00,$00,$00,$09,$c0,$7c
  comment = if ARG1() < 0 then goto ARG2
  argument
    rbyte = 1
    type  = faraddress
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
;   if funct() >= 0 then goto ...
;
macroname = IFGEZ
  size    = 4
  mask    = $ff,$00,$00,$00,$00,$ff,$ff,$ff
  compare = $9a,$00,$00,$00,$00,$09,$c0,$7d
  comment = if ARG1() >= 0 then goto ARG2
  argument
    rbyte = 1
    type  = faraddress
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
;   if funct() > 0 then goto ...
;
macroname = IFGTZ
  size    = 4
  mask    = $ff,$00,$00,$00,$00,$ff,$ff,$ff
  compare = $9a,$00,$00,$00,$00,$09,$c0,$7f
  comment = if ARG1() > 0 then goto ARG2
  argument
    rbyte = 1
    type  = faraddress
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
;   Test two global integers and jump if condition met.
;
macroname = IFEQ
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $a1,$00,$00,$3b,$06,$00,$00,$74
  comment = if ARG1 = ARG2 goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFNEQ
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $a1,$00,$00,$3b,$06,$00,$00,$75
  comment = if ARG1 <> ARG2 goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFLE
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $a1,$00,$00,$3b,$06,$00,$00,$76
  comment = if ARG1 <= ARG2 goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFLT
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $a1,$00,$00,$3b,$06,$00,$00,$72
  comment = if ARG1 < ARG2 goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFGE
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $a1,$00,$00,$3b,$06,$00,$00,$73
  comment = if ARG1 >= ARG2 goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFGT
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $a1,$00,$00,$3b,$06,$00,$00,$77
  comment = if ARG1 > ARG2 goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
;   Test two local integers and jump if condition met.
;
macroname = IFEQ
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $8b,$00,$00,$3b,$06,$00,$00,$74
  comment = if ARG1 = ARG2 goto ARG3
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 5
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFNEQ
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $8b,$00,$00,$3b,$06,$00,$00,$75
  comment = if LARG1 <> LARG2 goto ARG3
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 5
    type  = word
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFLE
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $8b,$00,$00,$3b,$06,$00,$00,$76
  comment = if LARG1 <= LARG2 goto ARG3
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 5
    type  = word
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFLT
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $8b,$00,$00,$3b,$06,$00,$00,$72
  comment = if LARG1 < LARG2 goto ARG3
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 5
    type  = word
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFGE
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $8b,$00,$00,$3b,$06,$00,$00,$73
  comment = if LARG1 >= LARG2 goto ARG3
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 5
    type  = word
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
macroname = IFGT
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $8b,$00,$00,$3b,$06,$00,$00,$77
  comment = if LARG1 > LARG2 goto ARG3
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 5
    type  = word
  endargument
  argument
    rbyte = 8
    type  = nearaddress
  endargument
endmacro
;
;   Simple integer assignment. Statement form is "i:=j;".
;
macroname = AsgnInt
  size    = 2
  mask    = $ff,$00,$00,$ff
  compare = $a1,$00,$00,$a3
  comment = "int assign, ARG2:=ARG1"
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 4
    type = address
    segment = ds
  endargument
 endmacro
;
;   Macro to set an interupt vector's handler address.
;
macroname = SetVector
  size    = 5
  mask    = $ff,$00,$00,$ff,$00,$ff,$ff,$ff
  compare = $ba,$00,$00,$b8,$00,$25,$cd,$21
  flags   = call
;
;   First show the interupt intercepted.
;
  argument
    rbyte = 4
    type  = byte
  endargument
;
;   Now the handler's address.
;
  argument
    rbyte = 1
    type  = address
    segment = cs
  endargument
endmacro
;
;   Macro to push the long address of a CONSTANT to the stack. Constants are
;   stored in the code segment.
;
macroname = PushConstAddr
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$0e,$57
  comment = push address of constant
;
;   Get address of constant to push.
;
  argument
    rbyte = 1
    type  = address
    segment = cs
  endargument
endmacro
;
;   Macro to push the long address of a VARIABLE to the stack. Variables are
;   stored in the data segment.
;
macroname = PushVarAddr
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $bf,$00,$00,$1e,$57
  comment = push address of variable
;
;   Get address of constant to push.
;
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to push the address of a VAR argument. That is where its address is
;   passed on the stack.
;
macroname = PushArgAddr
  size    = 4
  mask    = $ff,$ff,$00,$ff,$ff
  compare = $c4,$7e,$00,$06,$57
  comment = push address of local variable
  argument
    rbyte = 2
    type  = byte
  endargument
endmacro
;
;   Macro to push the address of a local variable to the stack.
;
macroname = PushLocalAddr
  size    = 4
  mask    = $ff,$ff,$00,$00,$ff,$ff
  compare = $8d,$be,$00,$00,$16,$57
  comment = push addr of LVAR
  argument
    rbyte = 2
    type  = word
  endargument
endmacro
;
;   Get the address of a global variable.
;
macroname = GetAddr
  size    = 6
  mask    = $ff,$00,$00,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $b8,$00,$00,$8c,$da,$a3,$00,$00,$89,$16
  comment = "ARG2 = address of ARG1"
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 6
    type  = address
    segment = ds
  endargument
endmacro
;
;   Get the address of a global procedure.
;
macroname = GetAddr
  size    = 7
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff,$00,$00,$ff,$ff
  compare = $b8,$00,$00,$ba,$00,$00,$a3,$00,$00,$89,$16
  comment = "ARG2 = address of proc ARG1"
  argument
    rbyte = 1
    type  = address
    segment = cs
  endargument
  argument
    rbyte = 7
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macro to push an immediate value.
;
macroname = _PushWrd   ; push three words in a row.
  size    = 6
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $b8,$00,$00,$50,$b8,$00,$00,$50,$b8,$00,$00,$50
  flags   = perm
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 5
    type  = word
  endargument
  argument
    rbyte = 9
    type  = word
  endargument
endmacro
;
macroname = _PushWrd   ; push two words in a row.
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$00,$00,$ff
  compare = $b8,$00,$00,$50,$b8,$00,$00,$50
  flags   = perm
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 5
    type  = word
  endargument
endmacro
;
macroname = _PushWrd   ; push 1 word.
  size    = 2
  mask    = $ff,$00,$00,$ff
  compare = $b8,$00,$00,$50
  argument
    rbyte = 1
    type  = word
  endargument
endmacro
;
;   Push a zero word.
;
macroname = _PushZero
  size    = 3
  nomask
  compare = $31,$c0,$50
endmacro
;
macroname = _PushByte   ; push two bytes in a row.
  size    = 4
  mask    = $ff,$00,$ff,$ff,$00,$ff
  compare = $b0,$00,$50,$b0,$00,$50
  argument
    rbyte = 1
    type  = byte
  endargument
  argument
    rbyte = 4
    type  = byte
  endargument
endmacro
;
macroname = _PushByte   ; push 1 byte.
  size    = 2
  mask    = $ff,$00,$ff
  compare = $b0,$00,$50
  argument
    rbyte = 1
    type  = byte
  endargument
endmacro
;
macroname = _PushByte   ; push 1 byte variable.
  size    = 4
  mask    = $ff,$00,$00,$ff,$ff,$ff
  compare = $a0,$00,$00,$30,$e4,$50
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macros to test registers and jump on zero or non-zero.
;
macroname = JALZ
  size    = 3
  nomask
  compare = $08,$c0,$74
  comment = jump if AL = 0 to ARG1
  argument
    rbyte = 3
    type  =nearaddress
  endargument
endmacro
;
macroname = JALNZ
  size    = 3
  nomask
  compare = $08,$c0,$75
  comment = jump if AL <> 0 to ARG1
  argument
    rbyte = 3
    type  =nearaddress
  endargument
endmacro
;
macroname = JAXZ
  size    = 3
  nomask
  compare = $09,$c0,$74
  comment = jump if AX = 0 to ARG1
  argument
    rbyte = 3
    type  =nearaddress
  endargument
endmacro
;
macroname = JAXNZ
  size    = 3
  nomask
  compare = $09,$c0,$75
  comment = jump if AX <> 0 to ARG1
  argument
    rbyte = 3
    type  =nearaddress
  endargument
endmacro
;
;   Macro to convert a byte variable into an integer.
;
macroname = CvrtB2I
  size    = 3
  mask    = $ff,$00,$00,$ff,$ff
  compare = $a0,$00,$00,$30,$e4
  comment = convert byte var to int (AX)
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
endmacro
;
;   Macros to support subscript computations.
;
macroname = GetSub
  size    = 5
  mask    = $ff,$00,$00,$ff,$ff,$ff,$ff
  compare = $ba,$00,$00,$f7,$e2,$8b,$f8
  flags   = perm
  comment = DI = AX * rec_size
  argument
    rbyte = 1
    type  = word
  endargument
endmacro
;
;   Macro to test a byte variable to see if it equals a specific value.
;
macroname = TEST_BVAR
  size    = 2
  mask    = $ff,$00,$00,$ff
  compare = $a0,$00,$00,$3c
  comment = does byte var at ARG1 = ARG2?
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 4
    type  = character
  endargument
endmacro
;
;   Macro to jump if a byte variable in AL does not equals a value (used in
;   CASE statements).
;
macroname = JAL_NEQ
  size    = 2
  mask    = $ff,$00,$ff
  compare = $3c,$00,$75
  comment = if byte var <> ARG1 goto ARG2
  argument
    rbyte = 1
    type  = character
  endargument
  argument
    rbyte = 3
    type  = nearaddress
  endargument
endmacro
;
;   Same as above for equals.
;
macroname = JAL_EQ
  size    = 2
  mask    = $ff,$00,$ff
  compare = $3c,$00,$74
  comment = if AL = ARG1 goto ARG2
  argument
    rbyte = 1
    type  = character
  endargument
  argument
    rbyte = 3
    type  = nearaddress
  endargument
endmacro
;
;   Macro to test an integer variable to see if it equals a specific value.
;
macroname = TEST_INT
  size    = 2
  mask    = $ff,$00,$00,$ff
  compare = $a1,$00,$00,$3d
  comment = does int var at ARG1 = ARG2?
  argument
    rbyte = 1
    type  = address
    segment = ds
  endargument
  argument
    rbyte = 4
    type  = word
  endargument
endmacro
;
;   Macro to jump if an int in AX does not equals a value (used in CASE
;   statements).
;
macroname = JAX_NEQ
  size    = 2
  mask    = $ff,$00,$00,$ff
  compare = $3c,$00,$00,$75
  comment = if AX <> ARG1 goto ARG2
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 4
    type  = nearaddress
  endargument
endmacro
;
;   Same as above for equals.
;
macroname = JAX_EQ
  size    = 2
  mask    = $ff,$00,$00,$ff
  compare = $3c,$00,$00,$74
  comment = if AX = ARG1 goto ARG2
  argument
    rbyte = 1
    type  = word
  endargument
  argument
    rbyte = 4
    type  = nearaddress
  endargument
endmacro
;
;   End of macro library.
