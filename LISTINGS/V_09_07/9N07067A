
/*
** declare a static variable
** (Modified for 2-D arrays) - D. Lang 1/91
*/
declglb(type, class) int type, class; {
int k, j, dim2, ndim;
char *ste; /* symbol table entry */
  dim2 = 1;
  ndim = 0;
  while(1) {
    if(match(";")) return;
    if(match("*")) {
      j=POINTER;
      k=0;
      }
    else {
      j=VARIABLE;
      k=1;
      }
    if(symname(ssname, YES)==0) illname();
    blanks();
    if(streq(lptr, "(")) {
      if(j==POINTER) error("pointer functions not allowed");
   if(type==CCHAR) error("character functions not allowed");
      if((class==STATIC)|(class==PUBLIC)) {
        newfunc(class);
        return;
        }
      else {
        j=FUNCTION;
        if(match("()") == 0) error("missing closing paren");
        }
      }
    if(findglb(ssname)) multidef(ssname);
    if(j!=FUNCTION) {
      if(match("[")) {
	k=needsub();  /* get size                         */
	j=ARRAY;      /* !0=array                         */
	ndim = 1;
	if(match("[")) {
	  dim2 = needsub();
	  ndim = 2;
	  if(dim2 == 0) {
	     error("need array size");
	     k = dim2 = 1;
	  } /* if dim2 */
	} /* if match */
      } /* if match */
    } /* if j!= */
 if(class!=EXTERNAL) j=initials(type>>2, j, k, class, dim2);
 ste=addsym(ssname, j, type, k, &glbptr, class, dim2, ndim);
    if(ste) ste[STATUS] |= DECLARED;
    if(match(",")==0) {ns(); return;}  /* more? */
    }
  }
 
/*
** declare local variables
** (Modified for 2-D arrays) - D. Lang 1/91
*/
declloc(typ) int typ; {
  int k, j, dim2, ndim;
#ifdef STGOTO
  if(noloc) error("not allowed with goto");
#endif
  if(declared < 0)  error("must declare first in block");
  while(1) {
    while(1) {
      if(endst()) return;
      if(match("*")) j=POINTER;
      else j=VARIABLE;
      if(symname(ssname, YES)==0) illname();
      /* no multidef check, block-locals are together     */
      k=BPW;
      if (match("[")) {
	ndim = 1;
        k=needsub();
        if(k) {
          j=ARRAY;
	  if(typ == CINT) k = k << LBPW;
	  if(match("[")) {
	      dim2 = needsub();
	      k = k * dim2;
	      ndim = 2;
	  }
	}
        else {
          j = POINTER;
          k = BPW;
	  if(match("[")) {
	      dim2 = needsub();
	      while(inbyte() != ']') if(endst()) break;
	      ndim = 2;
	   }
	  }
        }
      else if(match("()")) j=FUNCTION;
      else if((typ==CCHAR)&(j==VARIABLE)) k=SBPC;
      declared = declared + k;
      addsym(ssname, j, typ, csp - declared, &locptr,
				     AUTOMATIC, dim2, ndim);
      break;
      }
    if (match(",")==0) return;
    }
  }
 
/*
** initalize global objects
** (Modified for 2-D arrays) - D. Lang 1/91
*/
initials(size, ident, dim, class, dim2) int size, ident,
					 dim, class, dim2; {
  int savedim, savectxt, dimsz, sflag, otemp;
  savectxt = ctext;
  sflag = -1;
  ctext = 0; /* turn off interleaved source */
  litptr=0;
  if(dim==0) dim = -1;
  dimsz = dim * dim2;
  savedim=dim;
  if(class==PUBLIC) entry();
  startglob();
  if(match("=")) {
    if(match("{")) {
      while(dimsz) {
	otemp = dimsz;
	init(size, ident, &dimsz);
	if(match(",")==0) break;
	if(otemp != dimsz) sflag = 1;
        }
      needtoken("}");
      }
    else {
	  otemp = dimsz;
	  init(size, ident, &dimsz);
	  if (otemp != dimsz) sflag = 1;
      }
    }
  if((savedim == -1) & (sflag == -1)) {
    stowlit(0, size=BPW);
    ident=POINTER;
    }
  dumplits(size);
  dumpzero(size, dimsz);
  ctext = savectxt; /* restore source code interleave mode*/
  return ident;
  }

/*
** declare argument types
**
** called from "newfunc" this routine adds an entry in the
** local symbol table for each named argument
**
** rewritten per P. L. Woods (DDJ #52)
** (Modified for 2-D arrays) - D. Lang 1/91
*/
doargs(t) int t; {
  int j, legalname, dim2, ndim;
  char c, *argptr;
  while(1) {
    if(argstk==0) return;      /* no arguments            */
    if(match("*")) j=POINTER; else j=VARIABLE;
    if((legalname=symname(ssname, YES))==0) illname();
    if(match("[")) {   /* is it a pointer ?               */
      ndim = 1;
      /* yes, so skip stuff between "[...]"               */
      while(inbyte()!=']') if(endst()) break;
			   else if(streq(lptr,"[")) break;
      j=POINTER;      /* add entry as pointer             */
      if(match("[")) {
	dim2 = needsub();
	ndim = 2;
      }
    }
    if(legalname) {
      if(argptr=findloc(ssname)) {
        if(argptr[TYPE]==NULL) {
	  /* add details of type and address              */
          argptr[IDENT]=j;
          argptr[TYPE]=t;
	  putint((((argtop-getint(argptr+OFFSET, OFFSIZE))
		    *BPW)+STKFRSZ), argptr+OFFSET, OFFSIZE);
	  argptr[NDIM] = ndim;
	  putint(dim2, argptr + CDIM, 2);
          }
        else error("duplicate argument declaration");
        }
      else error("not an argument");
      }
    --argstk; /* count down */
    if(endst())return;
    if(match(",")==0) error(" no comma");
    }
  }
 

