
heir14(lval)  int *lval; {
  int k, const, val, lval2[8];
  char *ptr, *before, *start;
  k=primary(lval);
  ptr=lval[0];
  blanks();
  if((ch=='[')|(ch=='(')) {
    lval[5]=1;   /* secondary register will be used */
    while(1) {
      if(match("[")) {               /* [subscript] */
        if(ptr==0) {
          error("can't subscript");
          junk();
          needtoken("]");
          return 0;
          }
        else if(ptr[IDENT]==POINTER) rvalue(lval);
        else if(ptr[IDENT]!=ARRAY) {
          error("can't subscript");
          k=0;
          }
        setstage(&before, &start);
        lval2[3]=0;
	plunge2(0, 0, heir1, lval2, lval2);
					 /* lval2 deadend */
	needtoken("]");
	/* -- beginning of added code -- */
	if(match("[")) { /* we have more dimensions */
	       if(ptr[NDIM] < 2 ) {
		     error("too many dimensions");
				/* variable declared with */
		     junk();  /* less dimensions */
		     needtoken("]");
		     return 0;
	       }
	       if(lval2[3]) { /*Test for index being const*/
		    clearstage(before, 0);
		      /* ignore code generated by plunge2 */
		    ol("XCHG AX,BX");
		    ot("MOV AX,");
		    outdec(lval2[4]);
		    nl();
	       }
	       ol("PUSH BX");
	       if((lval2[3] == 0) | lval2[4]) {
		       if(ptr[TYPE] == CINT)
				/* Get 2nd dimension size */
			   const2(ptr[CDIM] << LBPW);
			      /* and adjust for type size */
		       else
			   const2(ptr[CDIM]);
		       mult(); /* AX gets CDIM * i1 */
	       }
	       setstage(&before, &start);
	       lval2[3] = 0;    /* parse sub 2 expression */
	       plunge2(0, 0, heir1, lval2, lval2);
	       needtoken("]");
	       if(lval2[3]) { /* if index is a constant */
		       clearstage(before, 0);
			 /* dump plunge2 generated code */
		       if(lval2[4]) /*if index is non-zero*/
			       if(ptr[TYPE] == CINT) {
				       ot("ADD AX,");
				       outdec(lval2[4]
						   << LBPW);
				       nl();
				  }
			       else {
				       ot("ADD AX,");
				       outdec(lval2[4]);
			       }
	       }
	       else {
		       if(ptr[TYPE] == CINT)
			       doublereg();
		       add(); /* AX gets CDIM*i1 + i2 */
	       }
	       ol("POP BX");
	       /* retrieve array base from stack */
	       add(); /* calculate segment addr of target */
	}
	else { /*  only one dimension  */
	/* -- end of new code -- */
	if(lval2[3]) {
          clearstage(before,0);
          if(lval2[4]) {
            if(ptr[TYPE]==CINT) const2(lval2[4]<<LBPW);
            else                const2(lval2[4]);
            add();
            }
          }
        else {
          if(ptr[TYPE]==CINT) doublereg();
          add();
	  }
	}
        lval[0]=lval[2]=0;
        lval[1]=ptr[TYPE];
        k=1;
        }
      else if(match("(")) {          /* function(...) */
	if(ptr==0) callfunction(0);
			   /* call to an absolute address */
        else if(ptr[IDENT]!=FUNCTION) {
          rvalue(lval);
          callfunction(0);
          }
        else callfunction(ptr);
        k=lval[0]=lval[3]=0;
        }
      else return k;
      }
    }
  if(ptr==0) return k; /* if constant, return */
  if(ptr[IDENT]==FUNCTION) {
	    /* if function name without "()", gen address */
    address(ptr);
    return 0;
    }
  return k;
  }
 
addsym(sname, id, typ, value, lgptrptr, class, cdim, ndim)
  char *sname, id, typ; int value, *lgptrptr, class, cdim,
						     ndim; {
  if(lgptrptr == &glbptr) {
    if(cptr2=findglb(sname)) return cptr2;
#ifdef HASH
    if(cptr==0) {
      error("global symbol table overflow");
      return 0;
      }
#else
#ifndef DYNAMIC
    if(glbptr >= ENDGLB) {
      error("global symbol table overflow");
      return 0;
      }
#endif
    cptr=*lgptrptr;
#endif
    }
  else {
    if(locptr > (ENDLOC-SYMMAX)) {
      error("local symbol table overflow");
      exit(EUSER);
      }
    cptr=*lgptrptr;
    }
  cptr[IDENT]=id;
  cptr[TYPE] =typ;
  cptr[CLASS]=class;
  cptr[STATUS]=0;
  putint(value, cptr+OFFSET, OFFSIZE);
  cptr[NDIM] = ndim;
  putint(cdim, cptr + CDIM, 2);
  cptr3 = cptr2 = cptr + NAME;
  while(an(*sname)) *cptr2++ = *sname++;
#ifdef HASH
  if(lgptrptr == &locptr) {
    *cptr2 = cptr2 - cptr3; /* set length */
    *lgptrptr = ++cptr2;
    }
#else
  *cptr2 = cptr2 - cptr3;   /* set length */
  *lgptrptr = ++cptr2;
#ifdef DYNAMIC
  if(lgptrptr == &glbptr) malloc(cptr2 - cptr);
  /* gets allocation error if no more memory */
#endif
#endif
  return cptr;
  }
 

