

















        C Spot Run

        A User-Supported C Add-On Library

        Version 2.1

        July 12, 1987


        Bob Pritchett
        New Dimension Software

        23 Pawtucket Dr.
        Cherry Hill, NJ 08003


        Copyright 1986, 1987 Bob Pritchett
        All Rights Reserved













































                                 To Mom and Dad

                   Your time, effort, encouragement and advice
                     have been far above and beyond what any
                           son could dream of asking.

                                     and to

                                  The Memory of
                               Thelma M. Pritchett

                        Your greatest works are the lives
                            of everyone who knew you.












                                   Trademarks

         MS-DOS and Microsoft C are trademarks of Microsoft Corporation.
            IBM-PC is a trademark of International Business Machines.
              C Spot Run is a trademark of New Dimension Software.
                Turbo C is a trademark of Borland International.
                C86 is a trademark of Computer Innovations, Inc.
                     Lattice is a trademark of Lattice, Inc.


                                   Disclaimer

             This  library and all of its contents are provided "AS  IS."  
        No  warranty is expressed or implied.  Use of this library is  at 
        the  user's  own risk,  and the authors are not  liable  for  any 
        damages  or loss of profits resulting from the use of the library 
        or its documentation.









                          C Spot Run - Documentation  



                                Table of Contents

            Dedication...............................................  2
            Trademarks...............................................  2
            Disclaimer...............................................  2

         1. Introduction.............................................  3
            1.1. What is C Spot Run?.................................  3
            1.2. Why C Spot Run?.....................................  3

         2. Obtaining and Copying C Spot Run.........................  4
            2.1. User Supported Software.............................  4
            2.2. Ownership of C Spot Run.............................  4
            2.3. Contents of C Spot Run..............................  4
            2.4. License for C Spot Run..............................  4
            2.5. Using C Spot Run in a Commercial Application........  5

         3. Using the C Spot Run Library.............................  6
            3.1. Using the Library with Your Compiler................  6
            3.2. Modifying the Library...............................  6
                 3.2.1. Problem Areas................................  6
                 3.2.2. Helpful Suggestions..........................  6
            3.3. Using the Utilities and Aids........................  7

         4. Format of Routine/Utility Descriptions...................  8
            4.1. How to Use Routine Description Pages................  8
            4.2. How to Use Utility Decription Pages.................  8

         5. The Library Routine Descriptions.........................
            5.1. General Descriptions of Related Routines............
                 5.1.1. Date Manipulation Routines...................
                 5.1.2. Directory Management Routines................
                 5.1.3. Graphics Routines............................
                 5.1.4. Input Routines...............................
                 5.1.5. Printer Operation Routines...................
                 5.1.6. Real Time Timers.............................
                 5.1.7. Sound Routines...............................
                 5.1.8. Window Function Library......................
            5.2. Individual Routine Descriptions.....................

         6. Utility and Aid Descriptions.............................

         7. Header File Descriptions.................................

         8. Appendix A - Updating the Library........................

         9. Appendix B - Contacting Authors..........................

        10. Appendix C - Submitting Routines or Utilities............

        11. Appendix D - Library History and Changes.................

        12. Appendix E - ASCII Table.................................



                                                           Page 3





                          C Spot Run - Documentation  


        13. Appendix F - Window Border Characters....................

        14. Quick Reference Chart....................................

        15. Commonly Asked Questions and Answers.....................

        16. Routine/Utility Submission Form..........................

        17. User Response Form.......................................

        18. Order Form...............................................














































                                                           Page 4





                          C Spot Run - Documentation  


        1. Introduction

           1.1.  What is C Spot Run?

             C  Spot  Run is a library of C and Assembly routines  for  C 
        programmers.   These  routines supplement the standard  libraries 
        provided  with  compilers,  and  provide  tools  for  specialized 
        applications.
             All routines in this library are either in the public domain 
        or  are  part of the user supported software world,  as  are  the 
        accompanying utilities and programming aids.  
             Our  goal  is  to  provide low  cost  (free!)  routines  and 
        utilities  for  C programmers.   The use of pre-written  routines 
        greatly reduces the amount of tedious code writing in almost  any 
        situation, and we hope that our collection will prove to do so.

           1.2.  Why C Spot Run?

             What  is  probably the next question to cross your  mind  is 
        simply,  why?   Good question,  and I hope this is a good answer.  
        Because.   Because  there  are so many libraries similar to  this 
        one.  Because they all cost money, and this one doesn't.  Because 
        as of yet there is no central distribution point for many of  the 
        C routines floating around in .C files everywhere.   We feel that 
        C Spot Run is filling a need, and we hope you agree with us.   
             We  would  appreciate your taking some time to let  us  know 
        what you think of the library and what directions you would  like 
        to see it take.  





























                                                           Page 5





                          C Spot Run - Documentation  


        2. Obtaining and Copying C Spot Run

           2.1. User Supported Software

             User  supported software is software distributed at no  cost 
        other  then a small media charge with the expectation that  those 
        who   find  it  useful  will  send  a  donation  to  support  the 
        development.    In   most  cases  those  who  contribute   become 
        registered users and receive automatic updates,  printed manuals, 
        telephone support, and/or source code.
             
           2.2. Ownership of C Spot Run

             Without  a major essay on copyright laws,  the routines  and 
        utilities  in  this package are the property of their  respective  
        authors,  with  the  exception of those released  to  the  Public 
        Domain (PD).  It is important to recognize the difference between 
        Public   Domain  and  user-supported  software.   (User-supported 
        includes  "ShareWare",   "FreeWare"  and  several  other  names.)  
        Unlike  authors  who totally give their software  to  the  public 
        domain,  some  authors  distribute  their  code  with  a  limited 
        license,  usually  something  to the effect that you are  not  to 
        distribute modified versions or charge for the distribution.  
             The  routines  and  utilities  in this  library  are  either 
        totally in the public domain,  in which case their source code is 
        present,  or have been released to this library for  distribution 
        as described in Appendix C of this document.
             As to the library itself,  and this documentation,  they are 
        property  of Bob Pritchett,  and released to the public under the 
        limited license in section 2.4.

           2.3. Contents of C Spot Run

             The  very  basic  principle  behind this  library  is  user-
        supported software.   In addition to monetary  contributions,  an 
        even  more valuable form is that of routines or utilities.   Most 
        of the routines and utilities in this library were written by two 
        or  three people,  or are modifications of other routines in  the 
        public domain.
             We would like to build a sizable library of tools and  helps 
        for C programmers,  and whether it is a new routine you wrote, or 
        one that is already in the public domain world, your contribution 
        of code and permission to let us use it would be appreciated.
             At  present  this library is a collection  of  routines  and 
        programming aids only.  Since the release of the first version of 
        the   library,   the   response  has  been  positive,   and   our 
        interpretation of it is that the library should continue to focus 
        on  routines  and  programming aids,  as opposed  to  creating  a 
        library of general C source code.

           2.4. Distribution License for C Spot Run

             The  C  Spot Run library of routines and  utilities  may  be 
        freely duplicated and distributed under the following terms:



                                                           Page 6





                          C Spot Run - Documentation  



             o  No fee may be charged other than  reasonable expenses for 
        media and reproduction, no more then eight dollars.

             o   The  library  MAY NOT be distrbuted  by  any  for-profit 
        corporation,  including,  but  not limited to,  for-profit public 
        domain software companies, without the express written permission 
        of Bob Pritchett.

             o  The routines,  utilities, and documentation are not to be 
        distributed in a modified form.

             o   The  routines  and  utilities are  not  to  be  used  in 
        commercial  applications  or  business environments  without  the 
        express written permission of the authors.

             o   Credit must be given to authors whose routines are  used 
        in  any  distributed application,  in both the code  and  program 
        documentation,  unless  other arrangements are made directly with 
        the author.

           2.5. Using C Spot Run in a Commercial Application

             You  are  free  to use parts of C Spot Run in  a  commercial 
        application,  on the following conditions:   You must purchase  a 
        copy  of the source code to C Spot Run at the commercial  license 
        fee  ($75),  becoming a registered user.   You may not distribute 
        any  part  of C Spot Run in a humanly readable  form.   You  must 
        include  the following statement in your application source  code 
        and  documentation:   "Portions of this program  Copyright  1986, 
        1987  New  Dimension  Software."   Additionally,   New  Dimension 
        Software  must  be notified of any commercial  programs  released 
        using the C Spot Run library.  
             These conditions are meant for my protection, curiosity, and 
        to assure that my work isn't used without credit.   If you have a 
        difficulty with any of them,  please contact me and we can try to 
        work something out.   (Along the lines of my curiosity,  I  would 
        like  to  see how the library is put to use,  and if you want  to 
        send me a copy of the programs you write with it, I won't mind.)


















                                                           Page 7





                          C Spot Run - Documentation  


        3. Using the C Spot Run Library

           3.1. Using the Library with Your Compiler

             All  utilities  included in this library work with  straight 
        ASCII text files,  unless otherwise specified,  and those dealing 
        with the syntax of the C language should work with all flavors of 
        C that conform to the basic guidelines in K&R. 
             The  routines  are distributed  in  several  forms,  usually 
        either  object  code or source code,  C  or  assembly.   Specific 
        information  on  each routine and it's compiler  dependancies  is 
        available  in  the  section entitled Compiler Specifics  in  each 
        routine  entry.  The  object  code in the libraries  provided  is 
        specific to a particular compiler, either Microsoft C or Turbo C.  
        These  libraries  and object code modules can be linked  to  your 
        program  with  the proper linker,  LINK or TLINK.   If  you  have 
        another  brand  compiler that is compatible with either of  these 
        object code formats you may be sucessful in linking the routines.  
        Keep  in  mind  that Microsoft and Turbo C  prepend  identifiers, 
        including function names,  with underscores.   If the source code 
        is  available  simply check it for compiler differences (see  the 
        next section) and compile it with whatever compiler you use.

           3.2. Modifying the Library

             Although  many compilers use the same routines,  they  often 
        are  named  differently,  or use a different set  of  parameters.  
        This section should be of assistance in modifying source to  work 
        with  your,  or  someone  else's,  compiler.   If you  have  some 
        information that could be helpful in compiler conversions, please 
        contact us.

                3.2.1. Problem Areas

             Some  of the more common differences in  compiler  libraries 
        are the naming conventions used.   For instance,  the routines to 
        perform  a DOS interrupt vary from intdos() to doint(),  and have 
        just as many differences in parameters.   Some common differences 
        are  in string manipulation,  hardware  specific  functions,  and 
        memory  management.   Here is some information that should be  of 
        help:

                3.2.2. Helpful Suggestions

             Microsoft  V4.0 uses unions declared in DOS.H as  parameters 
        for it's hardware/DOS functions unlike most other compilers which 
        need  the  register variables etc.  declared by  the  user.   The 
        register  variables are stored in a union of type REGS,  and  are 
        addressed  using the union member x to access registers with x as 
        a second character,  or h to access the registers ending in h  or 
        l.  Example: union REGS in;  n = in.x.ax;  y = in.h.bl;

             Microsoft's hardware interrupt is int86(int,&in,&out),  cor-
        responding  to sysint(int,&in,&out) used by many other compilers.  
        Likewise intdos(&in,&out) corresponds to sysint(0x21,&in,&out).


                                                           Page 8





                          C Spot Run - Documentation  



             Lattice/Computer  Innovation's  movmem(source,  destination, 
        width) corresponds to Microsoft's  movedata(destination,  source, 
        width).

             Turbo  C is almost completely compatible with  Microsoft  C, 
        with a few small exceptions.   For example, Microsoft's inp() and 
        outp()  are named inport() and outport(),  and some header  files 
        differ slightly in name.

           3.3. Using the Utilities and Aids

             The  use of utilities and programming aids should be clearly 
        described on their description pages.   All include files  should 
        be  included at the beginning of sources that need them,  and  in 
        addition  to the description page most independant utilities will 
        provide  a  short summary of their use when run with  no  command 
        line parameters.







































                                                           Page 9





                          C Spot Run - Documentation  


        4. Format of Routine/Utility Descriptions

           4.1. How to Use the Routine Description Pages

             The  routine  description pages are set up in such a  manner 
        that  updates  to  the library will not  require  a  totally  new 
        manual.  
             Each  routine has its own full page regardless of how  small 
        or large it is.   The page is set up in a special order, with the 
        name of the routine on the upper right of the page at the top for 
        quick  indexing,  followed  by a short summary of  the  necessary 
        arguments  and their data types.   Next is a line containing  the 
        creation  and last update dates,  and then the author's name  and 
        whether  the  source is in C or Assembly.   Following these is  a 
        list of the files in which the code is contained, a list of other 
        required functions that may not be in every library,  and then  a 
        paragraph  description of the function.   This is followed with a 
        paragraph  explaining  any ties to  one  specific  compiler,  the 
        return value,  a list of related functions in the library,  and a 
        final example of how it might be used in a portion of code.
             It  is  recommended that you keep the complete manual  in  a 
        three  ring binder,  and as you receive updates simply print  out 
        the enclosed page,  and insert it in alphabetical order among the 
        function  description pages.   (This manual may seem like a waste 
        of paper, but this way it saves a lot in the long run.)

           4.2. How to Use the Utility Description Pages

             The  utility  description pages are similar to  the  routine 
        descriptions   described   above  except  for   the   layout   of 
        information.  On the utility description pages the first item is, 
        as  with the routine descriptions,  the utility name on the upper 
        right  hand corner.   Next is a summary of the utility  including 
        the creation and last update dates, the author's name, the source 
        language,  and then a copy of the documentation, usually an exact 
        duplicate of whatever documentation the author has sent.
             As  mentioned,  the  method for updating  these  description 
        pages is the same as above in section 4.1.



















                                                           Page 10








                                 Sound Functions

             The sound functions provided with C Spot Run can be used  to 
        make sound 'while you wait' or in an interrupt driven  background 
        mode.
             The  sound() function will play the note given for the  time 
        specified  and return when complete, or, in background mode,  put 
        the  note into the sound buffer and return immediately.  (If  the 
        buffer is full, sound() will wait until there is room.)
             The  play() function uses the sound() function and  whatever 
        mode it is set to.

             Background mode is set by calling the sound_init() function, 
        and  terminated  by calling sound_done().  It is  VERY  important 
        that  sound_done() is called before any program terminates.   The 
        sound_quiet()   and  sound_left()  functions  can  be  used   for 
        manipulation of the background sound buffer.

             The  spkr_<on|off|freq>()  functions  directly  control  the 
        speaker.   A  frequency  can  be  loaded  with  the   spkr_freq() 
        function, started with the spkr_on() function, and stopped by the 
        spkr_off() function.












































                                                                beep
        Summary:

        void beep();

        Created: 07/02/87        Last Updated: 07/02/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRBEEP.OBJ

        Requires: sound()

        Description:

        This  function outputs a 'less offensive' beep than the  standard 
        Control-G beep.  Additionally you can change the tone and length, 
        with the setbeep() function.  (Note:  All 'beeping' by other  CSR 
        functions is now done with this function.)

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        setbeep() sound()

        Example:

        /* ... */
           else                         /* If not acceptable input... */
              beep();                   /* beep to indicate error. */
        /* ... */




























                                                                cbox
        Summary:

        int cbox(x,y,x2,y2,type);
        int x;                   /* Upper Left Row */
        int y;                   /* Upper Left Col */
        int x2;                  /* Lower Right Row */
        int y2;                  /* Lower Right Col */
        int type;                /* Style of Border */

        Created: 03/03/86        Last Updated: 07/09/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CBOX.OBJ

        Requires: putchci() gotoxy()

        Description:

        This  function  is functionaly the same as box() except that  the 
        box  is drawn in the current color.   It is primarily used as  an 
        internal routine in COUTPUT.OBJ.  For independant use, use color() 
        or wcolor() to set the color. 

        Compiler Specifics:

        None.

        Return Value:

        Returns  a  one  if  successful,   a  negative  one  if   invalid 
        coordinates are passed.

        See Also:

        color() wcolor() box()

        Example:

        #include <color.h>       /* Just for the colors... */

        color(RED_F,WHT_B);      /* Red on White */

        cbox(5,5,20,60,1);       /* A box with a single line border */





















                                                              chline
        Summary:

        int chline(x,y,y2,type);
        int x;                   /* Upper Left Row */
        int y;                   /* Upper Left Col */
        int y2;                  /* Lower Right Col */
        int type;                /* Style of Border */

        Created: 03/03/86        Last Updated: 07/09/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CHLINE.OBJ

        Requires: putchci() gotoxy()

        Description:

        This  function  will  draw  a  line at  x,y  to  x,y2  using  the 
        character(s) specified in type.   Type may be any one of the five 
        types  accepted by box().   Usually this function is used to draw 
        lines  inside boxes,  as it will use the proper side  characters, 
        but by using an ASCII character in type an ordinary line of  that 
        character is drawn.   The line is drawn in the current color,  as 
        specified by color().

        Compiler Specifics:

        None.

        Return Value:

        Returns  a  one  if  successful,   a  negative  one  if   invalid 
        coordinates are passed.

        See Also:

        cvline() whline()

        Example:

        #include <color.h>       /* Just for the colors... */

        color(RED_F,WHT_B);      /* Red on White */

        cbox(5,5,20,60,1);       /* A box with a single line border */

        chline(5,7,60,1);        /* Draws a line across the box */

















                                                              clreol
        Summary:

        int clreol();

        Created: 07/10/87        Last Updated: 07/10/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CLREOL.OBJ

        Requires: gotoxy() putchci() cursor_read()

        Description:

        This  function reads the current cursor position and  clears,  in 
        the  color set by the color() function, the line from the  cursor 
        to  column 80.  The cursor is returned to the location it was  at 
        before the function was called.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        cls() gotoxy() cursor_read() color()

        Example:

        gotoxy(7,10);
        clreol();






























                                                               color
        Summary:

        #include <color.h>       /* For Color Definitions Only */

        int color(attr)
        int attr;                /* Color Attributes */

        Created: 03/03/86        Last Updated: 07/09/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRCOLOR.OBJ

        Requires: Nothing.

        Description:

        This  routine  sets  the  colors  to be  used  in  all  following 
        operations  involving  color  in  the  windows  package,   unless 
        otherwise  specified.    In  version  1.0  color()  required  two 
        arguments,  the  fore  and background  attributes.   To  maintain 
        compatibility  with other <x>color() routines,  there is now only 
        one argument, with the attributes added together.

        If  color()'s  argument is -1,  it returns the current value  for 
        color operations.   This is useful if you wish to write windowing 
        functions that restore the current color attributes after opening 
        their own windows.

        Compiler  Specifics:

        None.

        Return Value:

        The color is returned.

        See Also:

        wcolor() mcolor()

        Example:

        #include <color.h>

        color(RED_F+BOLD+BLU_B);      /* Bold Red on Blue. */



















                                                              cvline
        Summary:

        int cvline(y,x,x2,type);
        int y;                   /* Upper Left Col */
        int x;                   /* Upper Left Row */
        int x2;                  /* Lower Right Row */
        int type;                /* Style of Border */

        Created: 03/03/86        Last Updated: 07/09/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CVLINE.OBJ

        Requires: putchci() gotoxy()

        Description:

        This  function  will  draw  a  line at  x,y  to  x2,y  using  the 
        character(s) specified in type.   Type may be any one of the five 
        types  accepted by box().   Usually this function is used to draw 
        lines  inside  boxes,  as it will use the proper top  and  bottom 
        characters,  but by using an ASCII character in type an  ordinary 
        line  of  that  character is drawn.   The line is  drawn  in  the 
        current color, as specified by color().

        Compiler Specifics:

        None.

        Return Value:

        Returns  a  one  if  successful,   a  negative  one  if   invalid 
        coordinates are passed.

        See Also:

        chline() wvline()

        Example:

        #include <color.h>       /* Just for the colors... */

        color(RED_F,WHT_B);      /* Red on White */

        cbox(5,5,20,60,1);       /* A box with a single line border */

        cvline(7,5,20,1);        /* Draws a line down the box */

















                                                            fbreakon
        Summary:

        #include <skey.h>        /* Needed Only for Key Descriptions */

        int fbreakon(x);
        int x;                   /* Special Key to Break On */

        Created: 06/29/87        Last Updated: 06/29/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: FINPUT.OBJ

        Requires: Nothing.

        Description:

        This  function  allows the programmer to set which  special  keys 
        will cause the finptstred() to exit.  Each call to this  function 
        adds the argument given to the list of break keys.  (The #include 
        file  SKEY.H  contains easy definitions for  the  special  keys.)  
        When given zero as an argument the list is cleared.

        The default break keys are HOME, END, PGUP, PGDN, UARROW, DARROW, 
        ALTE, ALTX, and ALTQ.

        Compiler Specifics:

        None.

        Return Value:

        Nothing is returned.

        See Also:

        wfbreakon() finptstred()

        Example:

        #include <skey.h>

        char temp[30];

        fbreakon(0);                    /* Clear List */
        fbreakon(ALTH);                 /* Alt-H Only */

        if ( finptstred(10,10,25,temp,"Default") == ALTH )
           help();
















                                                          finptstred
        Summary:

        int finptstred(rw,cl,mx,str,def);
        int rw;                  /* Row of Field */
        int cl;                  /* Column of Field */
        int mx;                  /* Length of Field */
        char *str;               /* Where to Place Input */
        char *def;               /* Default String */

        Created: 10/18/86        Last Updated: 06/29/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: FINPUT.OBJ

        Requires: gotoxy() cfield()

        Description:

        This  powerful function displays the field specified  and  places 
        the  default  string  within  it, and the  cursor  at  the  first 
        character  of  this string.  The default string may  be  returned 
        with a carriage return as the first character, it may be  editted 
        with the left and right arrow keys and ins and del, the field may 
        be  erased with the Alt-X combination, and the default input  can 
        be  restored with the Alt-D combination.  Editting  is  performed 
        with  the  ins and del keys in combination with movement  by  the 
        left  and  right arrow keys.  The insert key will  toggle  insert 
        'mode' on and off, although the cursor will not reflect the  mode 
        change.   When in insert mode all characters to the right of  the 
        cursor  will  move right (and possibly scroll out of  the  field) 
        when  characters  are  inputted.   The del  key  will  erase  the 
        character the cursor rests on and move everything to the right of 
        the cursor left one space.  In order to allow for design of  full 
        input  screens  the function will return with the  input  in  the 
        appropriate location and the value of the key as the return value 
        if  one  of  several extended function keys  is  entered.   These 
        special  keys are those on the break list, which is  modified  by 
        the fbreakon() function.  (The list of default keys is under  the 
        description of this routine.) 

        Compiler Specifics:

        None.

        Return Value:

        A  one is returned unless input was terminated by a special  key, 
        in which case its value will be returned.  (Special keys return a 
        null followed by an integer.  The integer is returned here.)















                                                          finptstred


        See Also:

        inptstr() finptint() wfinptintd() ffill() finptstr() 
        wfinptstred() fbreakon()

        Example:

        char temp[80];
        int x;

        x = finptstred(10,10,25,temp,"C Spot Run");

        if ( x != 1 )                 /* Special Value */
           process(x);                /* Process Key */

















































                                                                play
        Summary:

        int play(mstr);
        char *mstr;              /* Music String to Play */

        Created: 02/20/86        Last Updated: 07/05/87

        Author: Paul Canniff          Source (C/A): A

        Located in: CSRPLAY.OBJ

        Requires: sound()

        Description:

        This  function plays a music string using the  sound()  function, 
        meaning that fore/background mode is determined by sound().

        The  format  for  the  string is the  same  as  that  of  BASICA.  
        Summarized, the following options are available:  (Lengths are  1 
        for whole note, 2 for half, 4 for quarter, etc.)

            A-G[x][.]   Play the note in the current octave.  The  length 
                        can  be  set by x, or the default is  used.   The
                        note may be dotted.
            L<x>        Sets the default length.
            M<N|L|S>    Sets mode.  (Normal, Legato, Staccato.)
            N<x>        Plays note x.  (0..84)  Default values used.
            O<x>        Sets the octave, from 0 to 7.
            P[x][.]     Pauses for a specified time.
            T<x>        Sets the tempo, from 32 to 255.
            <           Go down one octave.
            >           Go up one octave.

        (Note:  The timing may need to be played with for your  hardware.  
        Try adjusting the tempo.)

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sound_init() sound_done()

        Example:

        play("MLc2.d ab>cd<ep2fgab");        /* Some Noise */
                /* See CSRDEMO.C for a real example. */












                                                             pmclose
        Summary:

        void pmclose(mn);
        int mnu;                 /* Menu to Close */

        Created: 07/02/87        Last Updated: 07/03/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRMENU.OBJ

        Requires: Nothing.

        Description:

        This  function  will  close the window associated  with  the  mnu 
        pointer and free any memory allocated for it.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        pmopen() pmrun() pmenu() pop_menu()

        Example:

        char *stuff[3] = 
         {
          "Option 1",
          "Second Option",
          "Your Third Choice"
         };

        main()
         {
          int m;
          int x;
          m = pmopen(10,10,"[ Menu ]",3,stuff,1);
          x = pmrun(m);
          pmclose(m);
          printf("\nMenu Choice %d Chosen.\n");
         }

















                                                             pmcolor
        Summary:

        void pmcolor(nm,bd,br);
        int nm;                  /* Menu's Inside Color */
        int bd;                  /* Menu's Border Color */
        int br;                  /* Highlight Bar Color */

        Created: 07/05/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRMENU.OBJ

        Requires: Nothing.

        Description:

        This  function  sets the colors used for by menu's  created  with 
        pmopen() and run with pmrun().

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        pmopen() pmrun()

        Example:

        char *stuff[3] = 
         {
          "Option 1",
          "Second Option",
          "Your Third Choice"
         };

        main()
         {
          int m;
          int x;
          pmcolor(RED_F,WHT_F,RED_F+WHT_B);
          m = pmopen(10,10,"[ Menu ]",3,stuff,1);
          x = pmrun(m);
          pmclose(m);
          printf("\nMenu Choice %d Chosen.\n");
         }














                                                               pmenu
        Summary:

        #include <csrmenu.h>     /* Contains MENU typedef */

        int pmenu(menu);
        MENU menu;               /* Pointer to Menu Structure */

        Created: 08/08/86        Last Updated: 08/20/86

        Author: Bob Pritchett         Source (C/A): C

        Located in: MENU.OBJ

        Requires: Nothing.

        Description:

        This function will display a pop up menu and allow for  selection 
        of an item with the arrow keys,  or the space and backspace keys. 
        The  differences between pmenu() and pop_menu() are mostly in the 
        calling method.   By using a data element of the MENU type as the 
        only argument, the number of parameters specifiable is increased, 
        allowing  for  better control of the menu,  while the  number  of 
        function arguments is reduced to one for cleaner coding.

        If the first character in an item name is a hyphen, the item will 
        be a horizontal line of the border color and type.  If the return 
        value  of  an  element  is  a  negative  one,  the  item  is  non 
        selectable.

        Note,  unlike  pop_menu(),  pmenu() will center the text of  each 
        entry to the width of the largest entry.  If you place a space on 
        each side of only the largest (widest) entry in a menu structure, 
        all menu options will have at least one space on each side.

        For information on specification of menus,  read the  description 
        of CSRMENU.H.

        Compiler Specifics:

        None.

        Return Value:

        The value of the menu item selected or a -1 for failure.

        See Also:

        pop_menu()
















                                                               pmenu




        Example:

        #include <csrmenu.h>
        #include <color.h>

        MENU mnu;

        main() 
         {
          int x;
          strcpy(mnu->title,"Menu");
          mnu->type = 3;
          mnu->border = WHT_F+BLU_B;
          mnu->normal = RED_F+WHT_B;
          mnu->bar = WHT_F+RED_B;
          mnu->row = 6;
          mnu->col = 20;
          mnu->num = 4;
          strcpy(mnu->entry[0].text,"Help");
          mnu->entry[0].value = 1;
          strcpy(mnu->entry[1].text,"Exit");
          mnu->entry[1].value = 2;
          strcpy(mnu->entry[2].text,"-");
          mnu->entry[2].value = -1;
          strcpy(mnu->entry[3].text," Static ");
          mnu->entry[3].value = -1;
          x = pmenu(mnu);
          if ( x == -1 )
             exit(1);
          else if ( x == 1 )
             help();
          else
             exit(0);
          .
          .
          .
         }
























                                                              pmfunc
        Summary:

        void pmfunc(func);
        int (*func)();           /* Function to be Called */

        Created: 07/03/87        Last Updated: 07/03/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRMENU.OBJ

        Requires: Nothing.

        Description:

        This function will set the name of a function to be called  while 
        pmrun()  is  waiting  for a keystroke.  This  function  must  run 
        continuously  until  a  keystroke is  hit.   (It  should  contain 
        something like a 'while ( ! kbhit() )' statement.)

        A  suggested  use  would be to update the time and  date  on  the 
        screen.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        pmopen() pmrun()































                                                              pmfunc




        Example:

        int dtw;

        char *stuff[3] = 
         {
          "Option 1",
          "Second Option",
          "Your Third Choice"
         };

        main()
         {
          int m;
          int x;
          int update();
          dtw = wopen(1,61,4,78,1);
          pmfunc(update);
          m = pmopen(10,10,"[ Menu ]",3,stuff,1);
          x = pmrun(m);
          pmclose(m);
          printf("\nMenu Choice %d Chosen.\n");
         }

        update()
         {
          int d,mn,y;
          int h,m,s,hs;
          while ( ! kbhit() )
           {
            get_date(&d,&mn,&y);
            get_time(&h,&m,&s,&hs);
            whome(dtw);
            wprintf(dtw," Date: %02d/%02d/%d\n",mn,d,(y-1900));
            wprintf(dtw," Time: %02d:%02d:%02d",h,m,s);
           }
         }
























                                                              pmopen
        Summary:

        int pmopen(r,c,title,argc,argv,type);
        int r;                   /* Upper Left Corner Row */
        int c;                   /* Upper Left Corner Column */
        char *title;             /* Title of Menu */
        int argc;                /* Option Count */
        char *argv[];            /* Options */
        int type;                /* Border Type of Menu */

        Created: 07/02/87        Last Updated: 07/03/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRMENU.OBJ

        Requires: Nothing.

        Description:

        This function opens a menu and sets up the internal data  without 
        allowing  the  user to use the menu.  The  options  are  centered 
        according  to the length of the longest one plus two.  (Left  and 
        right justified menus can be created by left or right  justifying 
        the options before calling pmopen().)

        Options  preceded by a '#' are static, meaning that they are  not 
        selectable.  Those preceded by a '-' will be replaced with a line 
        on the display.

        The integer value returned is a pointer to the menu for use  with 
        pmrun()  or pmclose().  There are eight available  pointers,  and 
        each menu can have as many as fifteen options.

        Compiler Specifics:

        None.

        Return Value:

        The menu pointer.

        See Also:

        pmclose() pmrun() pmenu() pop_menu()




















                                                              pmopen




        Example:

        int dtw;

        char *stuff[5] = 
         {
          "Option 1",
          "-This is a line."
          "Second Option",
          "#Unselectable",
          "Your Third Choice"
         };

        main()
         {
          int m;
          int x;
          int update();
          dtw = wopen(1,61,4,78,1);
          pmfunc(update);
          m = pmopen(10,10,"[ Menu ]",5,stuff,1);
          x = pmrun(m);
          pmclose(m);
          printf("\nMenu Choice %d Chosen.\n");
         }

        update()
         {
          int d,mn,y;
          int h,m,s,hs;
          while ( ! kbhit() )
           {
            get_date(&d,&mn,&y);
            get_time(&h,&m,&s,&hs);
            whome(dtw);
            wprintf(dtw," Date: %02d/%02d/%d\n",mn,d,(y-1900));
            wprintf(dtw," Time: %02d:%02d:%02d",h,m,s);
           }
         }






















                                                               pmrun
        Summary:

        void pmrun(mnu);
        int mnu;                 /* Menu to Run */

        Created: 07/03/87        Last Updated: 07/03/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRMENU.OBJ

        Requires: Nothing.

        Description:

        This function will 'run' the specified menu, assuming that is has 
        already been opened with the pmopen() function.

        If a function has been specified by the pmfunc() function it will 
        be  run until a key is hit, at which time pmrun()  processes  it.  
        Up and down arrows scroll the highlight bar through the menu,  as 
        do space and backspace.  Hitting the enter key causes pmrun()  to 
        return  the  number  of the  option  currently  highlighted,  and 
        entering  the first letter of an option will cause it  to  return 
        the  number of the FIRST option beginning with that letter.   The 
        ESCape key causes pmrun() to return a -1.

        Note  that pmrun() always highlights the first menu  option,  and 
        does not close the menu before returning the selected value.

        Compiler Specifics:

        None.

        Return Value:

        The  number  of  the option selected, or -1 in the  case  of  the 
        escape key.

        See Also:

        pmclose() pmopen() pmenu() pop_menu()























                                                               pmrun




        Example:

        char *stuff[5] = 
         {
          "Option 1",
          "-This is a line."
          "Second Option",
          "#Unselectable",
          "Your Third Choice"
         };

        main()
         {
          int m;
          int x;
          m = pmopen(10,10,"[ Menu ]",5,stuff,1);
          while ( 1 )
           {
            x = pmrun(m);
            if ( x == -1 )
               break;
            switch(x)
             {
              case 0:
                opt_one();
                break;
              case 2:
                opt_two();
                break;
              case 4:
                opt_three();
                break;
              default:
                break;
             }  
           }
          pmclose(m);
          printf("\nMenu Choice %d Chosen.\n");
         }






















                                                               putat
        Summary:

        int putat(x,y,string);
        int x;                   /* Row to Put At */
        int y;                   /* Col to Put At */
        char *string;            /* String to Put */

        Created: 12/28/85        Last Updated: 07/09/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: PUTAT.OBJ

        Requires: ccputs() putchci()

        Description:

        This  function  places the specified string at x,y on the  global 
        screen using the global color set by color().

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        putatf() wputat() wputatf()

        Example:

        putat(10,25,"+ The plus is at 10,25.");






























                                                              putatf
        Summary:

        int putatf(x,y,string,args...);
        int x;                   /* Row to Put At */
        int y;                   /* Col to Put At */
        char *string;            /* Formatted String to Put */
        args...                  /* Formatting Arguments */

        Created: 05/01/86        Last Updated: 07/09/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: PUTATF.OBJ

        Requires: ccputs() putchci()

        Description:

        This  performs the same function as putat() with the addition  of 
        up to 15 formatting arguments in the same format as printf().

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        putat() wputat() wputatf()

        Example:

        putatf(10,25,"+ The plus %s at %d,%d.","is",10,25);





























                                                      restore_cursor
        Summary:

        int restore_cursor(x);
        int x;                   /* Cursor to Restore */

        Created: 02/22/86        Last Updated: 07/02/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CURSOR.OBJ

        Requires: int86()

        Description:

        This  function restores the cursor to the location stored by  the 
        pointer  returned  by save_cursor().  Note:   This  function  has 
        changed since previous versions.

        Compiler Specifics:

        Problems associated with int86() only.

        Return Value:

        Nothing.

        See Also:

        save_cursor() restore_screen()

        Example:

        int x;
        int y;

        gotoxy(8,8);
        x = save_cursor();
        gotoxy(10,10);
        y = save_cursor();

        restore_cursor(x);      /* Return to 8,8 */
        restore_cursor(y);      /* Return to 10,10 */






















                                                         save_cursor
        Summary:

        int save_cursor();

        Created: 02/22/86        Last Updated: 07/02/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CURSOR.OBJ

        Requires: int86()

        Description:

        This  function  saves the current cursor position and  returns  a 
        pointer  to  that  saved  value.  This  must  be  used  with  the 
        restore_cursor() function to put the cursor back.  By using  this 
        method  of  pointers  functions can use  the  cursor  saving  and 
        restoring functions without fear of destroying another function's 
        data.

        Compiler Specifics:

        int86().

        Return Value:

        Nothing.

        See Also:

        restore_cursor()

        Example:

        int x;

        x = save_cursor();

        printf("This is a string of text...");

        restore_cursor(x);        /* To the beginning of the line... */ 























                                                             setbeep
        Summary:

        void setbeep(tone,length);
        int tone;                /* Tone for Beep */
        int length;              /* Length in Milliseconds */

        Created: 07/02/87        Last Updated: 07/02/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRBEEP.OBJ

        Requires: Nothing.

        Description:

        This function sets the tone and duration of the beep produced  by 
        beep().  The default values are 450 and 125.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        beep() setbeep()

        Example:

        setbeep(800,300);                     /* Long and High */

        beep();                               /* Output Beep */





























                                                              sndout
        Summary:

        void sndout(void);

        Created: 07/02/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: Nothing.

        Description:

        This  is  the  function  used internally  to  process  the  timer 
        interrupt for background sound when it is trapped by sndsetint().  
        It  increments a timer tick count and decides whether or  not  to 
        start or stop a note as it is playing.

        There is no need to use it apart from its related routines.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sndsetint() sndrstint()

        Example:

        /**** Internal Use Only ****/





























                                                           sndsetint
        Summary:

        void sndsetint(void);

        Created: 07/02/87        Last Updated: 07/02/87

        Author: Bob Pritchett         Source (C/A): A

        Located in: CSRSHND.OBJ

        Requires: Nothing.

        Description:

        This function stores the current timer interrupt handler and sets 
        it  to an internal routine that calls sndout() and then  the  old 
        handler.   No initialization of the background sound routines  is 
        done.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sndout() sndrstint()

        Example:

        /**** Internal Use Only ****/































                                                           sndrstint
        Summary:

        void sndrstint(void);

        Created: 07/02/87        Last Updated: 07/02/87

        Author: Bob Pritchett         Source (C/A): A

        Located in: CSRSHND.OBJ

        Requires: Nothing.

        Description:

        This function removes from the chain of timer interrupt  handlers 
        CSR's  background  sound  routines  and  replaces  the   previous 
        handler.   This function MUST be called before a  program  exits.  
        (The  sound_done()  function calls this function in  addition  to 
        cleaning  up  internal  variables.   One of  these  two  must  be 
        called.   It  is  recommended that  a  control-break  handler  is 
        installed to either call this function or one that will.)

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sndout() sndsetint() sound_done()

        Example:

        static int cbflag = 0;

        cbcapt(&cbflag);                /* Set Flag for Ctrl-Break */

        sound_init();                   /* Initialize Sound */

        while ( 1 )
         {
          /* Run Program Code - Break When Done */
          if ( cbflag )                 /* If Control-Break Occured */
           {
            sndrstint();                /* Restore Timer Handler */
            exit(1);                    /* Exit Program */
           }
         }
        sndrstint();                    /* Restore After Execution */
        exit(0);                        /* Program Exits Normally */












                                                               sound
        Summary:

        #include <csrsound.h>

        void sound(tone,duration);
        long tone;               /* Frequency in MegaHertz x 100 */
        long duration;           /* Length in Milliseconds */

        Created: 05/12/86        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: Nothing.

        Description:

        This  function  will put the specified note into the  buffer  and 
        return,  when  in background mode, or play the note  and  return.  
        (See the 'Sound' description of related routines in the beginning 
        of  this documentation.)  If sound is in background mode and  the 
        buffer  is full it will wait until there is room  before  placing 
        the note in the buffer.

        The tone variable must hold the frequency to be output multiplied 
        by  100.   (Previous  versions of sound worked  with  the  actual 
        frequency.)    The  duration  is  the  length  of  the  note   in 
        milliseconds, and should be reasonably accurate on all processors 
        and in both modes.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound_init() play() beep() setbeep()

        Example:

        #include <csrsound.h>

        sound(C,5000L);
        sound(D,2500L);
        sound(E,1250L);















                                                          sound_done
        Summary:

        void sound_done(void);

        Created: 07/02/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: sndrstint() spkr_off()

        Description:

        This  function calls sndrstint() to restore the  timer  interrupt 
        (which  MUST  be done before any program using  background  sound 
        exits) and turns off the speaker in case it was left on.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sound_init() sndsetint() sndrstint() play()

        Example:

        sound_init();
        /* Play something.... */
        sound_done();






























                                                          sound_init
        Summary:

        void sound_init(void);

        Created: 07/02/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: sndsetint()

        Description:

        This  function calls sndsetint() to trap the timer interrupt  and 
        sets up the sound routine to play notes in the background.   When 
        this  function  is called all subsequent calls  to  sound()  will 
        cause the notes to be played in background.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sound_done() sndsetint() sndrstint() play()

        Example:

        sound_init();
        /* Play something.... */
        sound_done();





























                                                          sound_left
        Summary:

        int sound_left(void);

        Created: 07/02/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: Nothing.

        Description:

        This  function  returns  the number of  notes  remaining  in  the 
        background sound buffer.

        Compiler Specifics:

        None.

        Return Value:

        The number of notes in the background sound buffer.

        See Also:

        sound() sound_init() sound_quiet() play() sound_done()

        Example:

        sound_init();
        /* Play something.... */
        wait_hs(500);                   /* Wait 5 Seconds */
        if ( sound_left() )             /* If Sound Remains */
           sound_quiet();               /*   Kill It */
        /* Go on with program.... */
        sound_done();



























                                                         sound_quiet
        Summary:

        void sound_quiet(void);

        Created: 07/02/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: spkr_off()

        Description:

        This  function aborts all of the sound in the buffer, resets  the 
        internal values, and turns off the speaker, but leaves the  sound 
        in background mode.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sound_init() sound_left() play() sound_done()

        Example:

        sound_init();
        /* Play something.... */
        wait_hs(500);                   /* Wait 5 Seconds */
        sound_quiet();                  /* Kill Whatever is Left */
        /* Go on with program.... */
        sound_done();



























                                                           spkr_freq
        Summary:

        void spkr_freq(tone);
        long tone;               /* Frequency x 100 to Set Speaker To */

        Created: 07/02/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: Nothing.

        Description:

        This  function sets up the speaker for a frequency but  does  not 
        play the frequency.  The spkr_on() function initiates the  actual 
        sound.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sound_init() sndout() spkr_on() spkr_off()

        Example:

        /***** Used Internally by sndout() *****/































                                                            spkr_off
        Summary:

        void spkr_off(void);

        Created: 07/02/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: Nothing.

        Description:

        This  function  simply turns off the speaker, cutting  short  any 
        sound currently being made.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sound_init() sndout() spkr_on() spkr_freq()

        Example:

        /***** Used Internally by sndout() *****/

































                                                             spkr_on
        Summary:

        void spkr_on(void);

        Created: 07/02/87        Last Updated: 07/05/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: CSRSOUND.OBJ

        Requires: Nothing.

        Description:

        This  function turns on the speaker, causing it to play  whatever 
        frequency  it  has loaded.  (See spkr_freq().)   The  sound  will 
        continue until spkr_off() is called.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        sound() sound_init() sndout() spkr_off() spkr_freq()

        Example:

        /***** Used Internally by sndout() *****/
































                                                             wait_hs
        Summary:

        int wait_hs(time);
        int time;                /* Hundredths of Seconds to Wait */

        Created: 06/18/87        Last Updated: 07/02/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: WAIT_HS.OBJ

        Requires: get_time()

        Description:

        This  function simply sits and waits for as many hundredths of  a 
        second as specified.  It is accurate to within the time it  takes 
        get_time() to run.  (If a key is hit during the delay, the  delay 
        is aborted and the keystroke returned.)

        Compiler Specifics:

        None.

        Return Value:

        Any key hit during the delay, or -1 if full delay endured.

        See Also:



        Example:

        if ( ( c = wait_hs(200) ) == -1 )        /* Wait 2 Seconds */
         {
          printf("Please Enter a Key!\n");
          c = getch();
         }


























                                                           wfbreakon
        Summary:

        #include <skey.h>        /* Needed Only for Key Descriptions */

        int wfbreakon(x);
        int x;                   /* Special Key to Break On */

        Created: 06/29/87        Last Updated: 06/29/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: WFINPUT.OBJ

        Requires: Nothing.

        Description:

        This  function  allows the programmer to set which  special  keys 
        will cause the wfinptstred() to exit.  Each call to this function 
        adds the argument given to the list of break keys.  (The #include 
        file  SKEY.H  contains easy definitions for  the  special  keys.)  
        When given zero as an argument the list is cleared.

        The default break keys are HOME, END, PGUP, PGDN, UARROW, DARROW, 
        ALTE, ALTX, and ALTQ.

        Compiler Specifics:

        None.

        Return Value:

        Nothing is returned.

        See Also:

        fbreakon() wfinptstred()

        Example:

        #include <skey.h>

        char temp[30];

        wfbreakon(0);                   /* Clear List */
        wfbreakon(ALTH);                /* Alt-H Only */

        if ( wfinptstred(10,10,25,temp,"Default") == ALTH )
           help();
















                                                         wfinptstred
        Summary:

        int wfinptstred(w,rw,cl,mx,str,def);
        int w;                   /* Window to Use */
        int rw;                  /* Row of Field */
        int cl;                  /* Column of Field */
        int mx;                  /* Length of Field */
        char *str;               /* Where to Place Input */
        char *def;               /* Default String */

        Created: 10/19/86        Last Updated: 06/29/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: WFINPUT.OBJ

        Requires: wgotoxy() cfield()

        Description:

        This  function  behaves as does finptstred() with  the  exception 
        that  it  works within a window.   Due to the complexity of  this 
        routine  and  the  fact  that it  is  functionally  identical  to 
        finptstred() the complete description is not repeated here.

        Compiler Specifics:

        None.

        Return Value:

        A  one is returned unless input was terminated by a special  key, 
        in which case its value will be returned.  (Special keys return a 
        null followed by an integer.  The integer is returned here.)

        See Also:

        inptstr() wfinptint() wfinptstred() wffill() wfinptstr() 
        finptstred() wfbreakon()

        Example:

        char temp[80];
        int x;
        int w;

        w = wopen(4,4,20,70,5);

        x = wfinptstred(w,10,10,25,temp,"C Spot Run");

        if ( x != 1 )                 /* Special Value */
           process(x);                /* Process Key */













                                                             wprintc
        Summary:

        int wprintc(win,str,clr);
        int win;                 /* Window to Use */
        char *str;               /* String to Print */
        int clr;                 /* Color to Print With */

        Created: 07/09/87        Last Updated: 07/09/87

        Author: Bob Pritchett         Source (C/A): C

        Located in: WPRINTC.OBJ

        Requires: wscolor() wprint()

        Description:

        This  function  sets  the specified window's  inside  and  border 
        colors to clr and prints the string.  The colors are not reset.

        Compiler Specifics:

        None.

        Return Value:

        Nothing.

        See Also:

        wprintf() wprint() wscolor()

        Example:

        wprintc(w3,"This line is output in red on white.\n",RED_F+WHT_B);



























                          C Spot Run - Documentation


                        Appendix A - Updating the Library

             The  C Spot Run routine library is constantly being added to 
        as  we receive contributions and write more  routines  ourselves.  
        In  the interest of saving time and space,  library updates  will 
        come in one of two forms.
             First,   small  collections  of  new  routines,   or  single 
        routines,  will be placed in archives along with a single page of 
        documentation  and  distributed via BBSs.  Registered users  will 
        receive information about new updates or a copy of those updates.  
        When  you  receive an update archive you simply place  the  files 
        into  your  library  or  linking  directory  and  print  out  the 
        documentation page,  which is then inserted in alphabetical order 
        into  the library description section of this manual.   (This  is 
        why  those pages are not numbered and we recommend  storing  your 
        manual in a three ring binder.)  
             Second,   major  updates  to  the  entire  library  will  be 
        distributed  in  archives  containing all  the  routines,  and  a 
        totally new version of the complete manual.   These updates  will 
        be on new version numbers.
             To  keep  on top of changes to the library it  is  suggested 
        that  you  read  issues of the C Spot Run  Newsletter  as  it  is 
        released,  and  make an occasional call to the support BBS  where 
        the  latest  version  of the library and  newsletter  are  always 
        available.






































                          C Spot Run - Documentation


                         Appendix B - Contacting Authors

             Each  description  page mentions the name of the  author  of 
        that routine, utility, or aid.  If for some reason you would like 
        to contact that author you may check the following directory  for 
        addresses  and  possibly  phone  numbers.  (NOTE:   All  of   the 
        following   authors  voluntarily  placed  their   addresses   and 
        sometimes  their  phone  numbers in this  directory.   They  have 
        indicated a willingness to answer questions by doing this, but we 
        ask you to be considerate with your calling hours.) 


             Mongelluzzo, Philip A.   (203) 574-2326 - Voice
               273 Windy Drive        (203) 271-1579 - Data (300/1200B)
               Waterbury, CT  06705

             Pritchett, Bob           (609) 424-2595 - Voice
               23 Pawtucket Drive     (609) 354-9259 - Data (300-2400B)
               Cherry Hill, NJ  08003       FidoNet: 107/414

             Roukas, George
               C/O Pinelands BBS      (609) 354-9259 - Data (300-2400B)









































                          C Spot Run - Documentation


                  Appendix C - Submitting Routines or Utilities

             All submissions to the routine library or utility collection 
        should  be  made using the Routine/Utility Submission  Form,  and 
        should be sent to the address on that form.   Please do not  make 
        additions to the library or utility collection on your own,  this 
        creates a problem and complicates the distribution.   
             In   addition  to  the  following  form  please  enclose   a 
        description  of the routine or utility,  preferably on an IBM  PC 
        disk  (360K  or  1.2Meg).   Please make this description  in  the 
        appropriate  format as specified in sections 4.1 and 4.2 of  this 
        manual.



















































                          C Spot Run - Documentation


                  Appendix D - History of Versions and Changes

             07/12/87  -  Version  2.1  released  with  bug  fixes,   new 
        routines,  Turbo C support, and a new version of the  newsletter.  
        Available  complete (CSR21.ARC) and as an update to Version  2.0.  
        (CSRUPDT2.ARC)

             06/02/87  - Preliminary  Version  2.0 support  for  Turbo  C 
        released.

             01/15/87  - Version  2.0A replaces 2.0,  which  was  missing 
        CheckC and FLine programs.

             01/10/87  - Version  2.0  of the library released  with  new 
        features and a new newsletter.

             10/13/86  - Limited release of version 1.1 of the library to 
        some  registered users.   Most bugs fixed,  manual  updated,  new 
        routines.

             06/27/86 - First issue of the newsletter released.

             05/05/86 - Version 1.0 of the library released.

             03/03/86 - Coding of Windowing routines begun.






































                          C Spot Run - Documentation


                        Appendix F - Window Border Styles


                                     Type 0

                               Borderless window.

                          Type 1                Type 2

                        +--------+            +========+  
                        |        |            |        |  
                        +--------+            :========:  
                        |        |            |        |  
                        +--------+            +========+  


                          Type 3                Type 4

                        ++======++            ++------++  
                        ||      ||            ||      ||  
                        |:======:|            |+------+|  
                        ||      ||            ||      ||  
                        ++======++            ++------++  


                                     Type 5

                    The actual plus and minus characters will
                  be used, resulting in a display identical to
                the non graphic representation of type number 1.


                               Any Other Character

                   If any other character is used as the type
              argument, that character will be used for the border.



























                          C Spot Run - Documentation


                              Quick Reference Chart

        Control-Break Routines
        ----------------------------------------
        cbcapt()       cbrest()

        Cursor Control Routines
        ----------------------------------------
        current_page() cursor_off()   cursor_on()    cursor_read()
        cursor_size()  gotoxy()       restore_cursor()
        save_cursor()

        Date Manipulation Routines
        ----------------------------------------
        chk_date()     date_sn()      day_of_year()  dt_diff()
        isleap()       month_day()    sn_date()      valid_date()

        Disk Drive Routines
        ----------------------------------------
        dirwin()       ffirst()       fnext()        get_drive()
        num_drives()   set_drive()

        Field Input Routines
        ----------------------------------------
        cfield()       fbreakon()     fchar()        fcolor()
        ffill()        finptint()     finptintd()    finptintr()
        finptintrd()   finptstr()     finptstrd()    finptstre()
        finptstred()   finptyn()      finptynd()

        Graphics Routines
        ----------------------------------------
        gback()        gbox()         gcircle()      gdot()
        gfbox()        ginit()        gline()        gpal()

        Input Routines
        ----------------------------------------
        inptint()      inptintd()     inptintr()     inptintrd()
        inptstr()      inptstrd()     inptyn()       inptynd()

        Menu Routines
        ----------------------------------------
        pmclose()      pmcolor()      pmfunc()       pmopen()
        pmrun()

        Miscellaneous Routines
        ----------------------------------------
        beep()         dosver()       getpw()        istemplate()
        itofa()        ltofa()        mcolor()       setbeep()
        soundex()      wait_hs()

        Printer Routines
        ----------------------------------------
        lprint()       lprintf()      lputchar()     print_screen()
        prtrns()









                          C Spot Run - Documentation


        Screen Control and Output Routines
        ----------------------------------------
        border()       box()          cbox()         ccenter()
        ccls()         ccputs()       center()       centerf()
        cfield()       chline()       clreol()       cls()
        cvline()       message()      mscroll()      pmenu()
        pop_menu()     putat()        putatf()       putchc()
        putchci()      restore()      restore_screen()
        save()         save_screen()  scroll()       set_mode()
        vidblt()

        Sound Routines
        ----------------------------------------
        play()         sndout()       sndrstint()    sndsetint()
        sound()        sound_done()   sound_init()   sound_left()
        sound_quiet()  spkr_freq()    spkr_off()     spkr_on()

        String Routines
        ----------------------------------------
        match()        soundex()      strcen()       strght()
        strlft()       strtrm()

        System Clock Routines
        ----------------------------------------
        get_date()     get_dow()      get_time()     set_date()
        set_time()

        Timer Routines
        ----------------------------------------
        get_timer()    init_tmr()     read_tmr()     reset_tmr()
        start_tmr()    stop_tmr()     timer()        zero_tmr()

        Window Routines
        ----------------------------------------
        cmenu()        color()        dma()          fixcolor()
        retrace()      wactivate()    wblank()       wborder()
        wcenter()      wcenterf()     wclose()       wcloseall()
        wcls()         wcol()         wcolor()       wdelete()
        wfreeze()      wgotoxy()      whline()       whome()
        winsert()      wjump()        wmessage()     wmove()
        wopen()        wprint()       wprintc()      wprintf()
        wputat()       wputatf()      wputchar()     wrow()
        wscolor()      wscroll()      wtitle()       wvline()

        Window Field Input Routines
        ----------------------------------------
        wfbreakon()    wfchar()       wfcolor()      wffill()
        wfinptint()    wfinptintd()   wfinptintr()   wfinptintrd()
        wfinptstr()    wfinptstrd()   wfinptstre()   wfinptstred()
        wfinptyn()     wfinptynd()

        Window Input Routines
        ----------------------------------------
        winptint()     winptintd()    winptintr()    winptintrd()
        winptstr()     winptstrd()    winptyn()      winptynd()








                          C Spot Run - Documentation


                      Commonly Asked Questions and Answers

             What  follows is a collection of some of the  most  commonly 
        asked  questions, and the answers.  If you don't find the  answer 
        to your particular problem here, please feel free to call.

             Q:   Where  are  all the .OBJ files listed  on  the  routine 
        description pages?

             A:   All  of the object code files are placed into  an  .LIB 
        file.   Each of the .LIB files provided contains all of the  .OBJ 
        files listed.  The .OBJ file names are provided so users with the 
        source  code  can find the source modules and to allow  users  to 
        find out which modules are in the same files. 


             Q:   I want to use C Spot Run in an application I'm  writing 
        to sell commercially.  What do I need to do?

             A:  You need to obtain a commercial license for C Spot  Run, 
        which  costs  $75, and comply with the simple terms  in  the  CSR 
        commercial usage license.  (Section 2.5 of this manual.)












































                         Routine/Utility Submission Form


        Name of Routine/Utility: ___________________________________

        Form(s) of Submission (C/ASM/OBJ/LIB/EXE/COM): _____________


        Are you releasing this  routine/utility to the Pubic  Domain 

        or under another program? (PD/Program):  ___________________


        If this  release is under a voluntary contribution  program, 

        what is the suggested contribution? ($): ___________________


        May we put your address in the author directory? (Y/N): ____

                                      Your phone number? (Y/N): ____

                                      Your data address? (Y/N): ____


             Name: _________________________________

          Address: _________________________________

             City: _____________________ State: ____  ZIP: _________

            Phone: (    )     -          Hours: ____________________

        Source ID: _______________  CompuServe ID: _________________

           Data #: (    )     -          Hours: ____________________

         Fido Net: ____ /_____            Baud: ____________________

        In  submitting  this form you place  your routine or utility 
        into the C Spot Run  C Add-on and Utility Library,  and give 
        permission  for it's  use as  specified  in  Appendix  C and
        sections one  and two of this manual.

        Please send this form via US Mail to the following  address,
        or via modem to the accompanying FidoNet address.

        Don't forget the description sheets, and of course the files
        you are submitting!

             C Spot Run
             New Dimension Software   FidoNet 107/414
               23 Pawtucket Drive      Data: (609) 354-9259
               Cherry Hill, NJ 08003












                               User Response Form


             We  would  like to hear from you,  and would appreciate  any 
        comments,  suggestions,  and/or donations.   Even if you are  not 
        making  a  donation  or contributing to  the  library,  we  would 
        appreciate some input,  and it helps us to know if the library is 
        serving  it's intended purpose,  and gives us some information on 
        our  users.   Of course this is voluntary,  but we hope you  will 
        take the time to fill out and mail this form.

        How did you obtain your copy of C Spot Run? ________________

        ____________________________________________________________


        What,  in your  opinion, are  the most  useful  routines and 

        utilities? _________________________________________________


        What do you think of the documentation? ____________________

        ____________________________________________________________


        Are  you enclosing  a contribution, and  if so, how much and

        why? _______________________________________________________


        Do you have any comments and/or suggestions? _______________

        ____________________________________________________________

        ____________________________________________________________


        Would you  like to be on a possible mailing list? (Y/N) ____


             Name: ________________________________________

          Company: ________________________________________

          Address: ________________________________________

             City: _____________________ State: ____  ZIP: _________

            Phone: (    )     -          Hours: ____________________

           Data #: (    )     -          Hours: ____________________

                                          Baud: ____________________













           Thank you, we hope you find the C Spot Run library of use.

        Please send this form via US Mail to the following  address,
        or via modem to the accompanying FidoNet address.


             C Spot Run
             New Dimension Software   FidoNet 107/414
               23 Pawtucket Drive      Data: (609) 354-9259
               Cherry Hill, NJ 08003























































                                   Order Form

             NOTE:   Users  who receive source code may not  redistribute 
        it.  The code is for your use only, and the right to redistribute 
        is  not included in the purchase.   If two or more people will be 
        using  the  source,  rather  then ordering just one  copy  please 
        contact the author about a discount on several copies.


             (  )  I would like to register as a C Spot Run User, receive 
        complete source code on disk, update notifications, and be placed 
        on  whatever mailing list may be formed.   I am enclosing  a  $50 
        donation.

             (   )  I would like to register as a C Spot Run user with  a 
        commercial   license,   receiving   all  the  benefits  of   full 
        registration with permission to use C Spot Run commercially under 
        the  conditions set forth in section 2.5.   I am enclosing a  $75 
        donation.

             (   )   I would like to register as a C Spot  Run  User  and 
        receive  all the benfits of such status with the exception of the 
        source code.  I am enclosing a $15 donation.


             Name: ________________________________________

          Company: ________________________________________

          Address: ________________________________________

             City: _____________________ State: ____  ZIP: _________

            Phone: (    )     -          Hours: ____________________

           Data #: (    )     -          Hours: ____________________

                                          Baud: ____________________


             C Spot Run
             New Dimension Software   Voice: (609) 424-2595
               23 Pawtucket Drive      Data: (609) 354-9259
               Cherry Hill, NJ 08003



           +--------------------  NDS USE ONLY  --------------------+
           |                                                        |
           |  Recieved:  ____ /____ /____   Sent: ____ /____ /____  |
           |                                                        |
           |             Serial Number: ________________            |
           |                                                        |
           +--------------------------------------------------------+









