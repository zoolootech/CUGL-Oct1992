


                                  - 1 -



                     XMODEM/YMODEM PROTOCOL REFERENCE
                 A compendium of documents describing the
                            XMODEM and YMODEM
                         file transfer Protocols











                         Edited by Chuck Forsberg














                 Please distribute as widely as possible.

                       Questions to Chuck Forsberg





                           Omen Technology Inc
                        17505-V Sauvie Island Road
                          Portland Oregon 97231
                           Voice: 503-621-3406
            Modem (Telegodzilla): 503-621-3746 Speed 1200,300
                          Compuserve: 70715,131
                    UUCP: ...!tektronix!reed!omen!caf








XMODEM/YMODEM Protocol Reference                                         1








                                  - 2 -
                                                                 Chapter 1


1.  TOWER OF BABEL ??

In the interest of fostering compatibility among communications programs,
part of of the Professional-YAM manual is reproduced here to minimize the
Electronic Tower of Babel.

The YMODEM Protocol is supported by the public domain programs YAM (CP/M),
YAM(CP/M-86), YAM(CCPM-86), rb/sb (Unix, Berkeley Unix, Venix, Xenix,
Coherent, IDRIS, Regulus) as well as Professional-YAM.  These programs
have been in use since 1981.

The protocols described below are enhancements to Ward Christensen's
XMODEM protocol, and are public domain.

The 1k packet length capability described below may be used in conjunction
with the Batch Protocol, or with single file transfers identical to the
XMODEM/CRC protocol except for minimal changes to support 1k packets.

To complete this tome, Ward Christensen's original protocol document and
John Byrns's CRC-16 document are included for reference.

References to the MODEM or MODEM7 protocol have been changed to XMODEM to
accommodate the vernacular.

Watch for an article describing the YMODEM protocol in a more coherent
fashion later this year.  This article will include some interesting
history on the development of file microcomputer file transfers.


1.1  Some Messages from the Pioneer

#: 130940 S0/Communications 25-Apr-85  18:38:47
Sb: my protocol
Fm: Ward Christensen 76703,302 (EDITED)
To: all


Be aware the article1 DID quote me correctly in terms of the phrases like
"not robust", etc.

It was a quick hack I threw together, very unplanned (like everything I
do), to satisfy a personal need to communicate with "some other" people.

ONLY the fact that it was done in 8/77, and that I put it in the public
domain immediately, made it become the standard that it is.


__________

 1. Infoworld April 29 p. 16



2                           Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 3 -
Chapter 1


I think its time for me to

(1) document it; (people call me and say "my product is going to include
it - what can I 'reference'", or "I'm writing a paper on it, what do I put
in the bibliography") and

(2) propose an "incremental extension" to it, which might take "exactly"
the form of Chuck Forsberg's YAM protocol.  He wrote YAM in C for CP/M and
put it in the public domain, and wrote a batch protocol for Unix called rb
and sb (receive batch, send batch), which was basically XMODEM with
   (a) a record 0 containing filename date time and size
   (b) a 1K block size option
   (c) CRC-16.

He did some clever programming to detect false ACK or EOT, but basically
left them the same.

People who suggest I make SIGNIFICANT changes to the protocol, such as
"full duplex", "multiple outstanding blocks", "multiple destinations", etc
etc don't understand that the incredible simplicity of the protocol is one
of the reasons it survived to this day in as many machines and programs as
it may be found in!

Consider the PC-NET group back in '77 or so - documenting to beat the band
- THEY had a protocol, but it was "extremely complex", because it tried to
be "all things to all people" - i.e. send binary files on a 7-bit system,
etc.  I was not that "benevolent". I (emphasize > I < ) had an 8-bit UART,
so "my protocol was an 8-bit protocol", and I would just say "sorry" to
people who were held back by 7-bit limitations.
...
Block size: Chuck Forsberg created an extension of my protocol, called
YAM, which is also supported via his public domain programs for UNIX
called rb and sb - receive batch and send batch.  They cleverly send a
"block 0" which contains the filename, date, time, and size.
Unfortunately, its UNIX style, and is a bit weird2 - octal numbers, etc.
BUT, it is a nice way to overcome the kludgy "echo the chars of the name"
introduced with MODEM7.  Further, chuck uses CRC-16 and optional 1K
blocks.  Thus the record 0, 1K, and CRC, make it a "pretty slick new
protocol" which is not significantly different from my own.

Also, there is a catchy name - YMODEM.  That means to some that it is the
"next thing after XMODEM", and to others that it is the Y(am)MODEM
protocol.  I don't want to emphasize that too much - out of fear that
other mfgrs might think it is a "competitive" protocol, rather than an


__________

 2. The Unix style stuff (time, file mode) is optional.  The pathname and
    file length may be sent alone if desired.



XMODEM/YMODEM Protocol Reference                                         3








                                  - 4 -
                                                                 Chapter 1


"unaffiliated" protocol.  Chuck is currently selling a much-enhanced
version of his CP/M-80 C program YAM, calling it Professional Yam, and its
for the PC - I'm using it right now.  VERY slick!  32K capture buffer,
script, scrolling, previously captured text search, plus built-in commands
for just about everything - directory (sorted every which way), XMODEM,
YMODEM, KERMIT, and ASCII file upload/download, etc.  You can program it
to "behave" with most any system - for example when trying a number for
CIS it detects the "busy" string back from the modem and substitutes a
diff phone # into the dialing string and branches back to try it.












































4                           Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 5 -
Chapter 2                                     XMODEM Protocol Enhancements


2.  XMODEM PROTOCOL ENHANCEMENTS

Professional-YAM uses several compatible extensions and logic enhancements
to the widely used Ward Christensen XMODEM protocol.

This chapter discusses the protocol extensions to Ward Christensen's 1982
XMODEM protocol description document.

YAM does not ask the operator whether he wishes to keep retrying after 10
attempts have failed to correctly transfer a packet.  Virtually all
correctable errors are corrected within the first few retransmissions.  If
the line is so bad that ten attempts are insufficient, there is a
significant danger of undetected errors.  In that case, it's better to
redial for a better connection.


2.1  CAN-CAN Abort

YAM recognizes a sequence of two consecutive CAN (Hex 18) characters
without modem errors (overrun, framing, etc.) as a transfer abort
command.1 The check for two consecutive CAN characters virtually
eliminates the possibility of a line hit aborting the transfer.  YAM sends
five CAN characters when it aborts a XMODEM protocol file transfer,
followed by five backspaces to delete the CAN characters from the remote's
keyboard input buffer (in case the remote had already aborted the
transfer).


2.2  CRC-16 Option

The XMODEM protocol uses an optional two character CRC-16 instead of the
one character arithmetic checksum used by the original protocol and by
most commercial implementations.  CRC-16 guarantees detection of all
single and double bit errors,  all errors with an odd number of error
bits, all burst errors of length 16 or less, 99.9969% of all 17-bit error
bursts, and 99.9984 per cent of all possible longer error bursts.  By
contrast, a double bit error, or a burst error of 9 bits or more can sneak
past the XMODEM protocol arithmetic checksum.

The XMODEM/CRC protocol is similar to the XMODEM protocol, except that the
receiver specifies CRC-16 by sending C (Hex 43) instead of NAK when
requesting the FIRST packet.  A two byte CRC is sent in place of the one
byte arithmetic checksum.  YAM's c option to the r command enables CRC-16
in single file reception, corresponding to the original implementation in


__________

 1. This is recognized when YAM is waiting for the beginning of a packet
    or for an acknowledge to one that has been sent.



XMODEM/YMODEM Protocol Reference                                         5








                                  - 6 -
XMODEM Protocol Enhancements                                     Chapter 2


the MODEM7 series programs.  Many commercial communications programs and
bulletin board systems still do not support CRC-16, especially those
written in Basic or Pascal.

XMODEM protocol with CRC is accurate provided both sender and receiver
both report a successful transmission.  The protocol is robust in the
presence of characters lost by buffer overloading on timesharing systems.

Professional-YAM add several proprietary logic enhancements to XMODEM's
error detection and recovery.  These compatible enhancements eliminate
most of the bad file transfers other programs make when using the XMODEM
protocol under less than ideal conditions.


2.3  1024 Byte Packet Option

If YAM is sending with the k option, the transmitted packet contains 1024
bytes of data.  An STX (02) replaces the SOH (01) at the beginning of the
transmitted block to notify the receiver of the longer packet length.  The
receiver should be able to accept any mixture of 128 and 1024 byte
packets.  The packet number is incremented by one for each packet.2

If 1024 byte packets are being used, it is possible for a 128 byte file to
"grow" to 1024 bytes on CP/M.  This does not waste disk space on CP/M
because the allocation granularity is 1k.  When 1024 byte packets are used
with batch transmission, the file length transmitted in the file name
packet allows the receiver to discard the padding.

CRC-16 should be used with the k option to preserve data integrity over
phone lines.  The k option may be used with batch file transmission, or
with single file transmission.














__________

 2. The displayed sector number should be the number of bytes divided by
    128.  This maintains a familiar unit of measurement for the progress
    report and avoids ambuguity caused by rollowver of the sector number.



6                           Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 7 -
Chapter 3                                     XMODEM Protocol Enhancements


          Figure 1.  1024 byte Packets
          SENDER                                  RECEIVER
                                                  "s -k foo.bar"
          "foo.bar open x.x minutes"
                                                  C
          STX 01 FE Data[1024] CRC CRC
                                                  ACK
          STX 02 FD Data[1024] CRC CRC
                                                  ACK
          STX 03 FC Data[1000] CPMEOF[24] CRC CRC
                                                  ACK
          EOT
                                                  ACK

          Figure 2.  Mixed 1024 and 128 byte Packets
          SENDER                                  RECEIVER
                                                  "s -k foo.bar"
          "foo.bar open x.x minutes"
                                                  C
          STX 01 FE Data[1024] CRC CRC
                                                  ACK
          STX 02 FD Data[1024] CRC CRC
                                                  ACK
          SOH 03 FC Data[128] CRC CRC
                                                  ACK
          SOH 04 FB Data[100] CPMEOF[28] CRC CRC
                                                  ACK
          EOT
                                                  ACK

3.  YMODEM Batch File Transmission

The YMODEM Batch protocol is an extension to the XMODEM/CRC protocol that
allows 0 or more files to be transmitted with a single command.  (Zero
files may be sent if none of the requested files is accessible.) The
design approach of the YAM Batch protocol is to use the normal routines
for sending and receiving XMODEM packets in a layered fashion similar to
packet switching methods.

Why was it necessary to design a new batch protocol when one already
existed in MODEM7?  The batch file mode used by MODEM7 is unsuitable
because it does not permit full pathnames, file length, file date, or any
other attribute information to be transmitted.  Such a restrictive design,
hastily implemented with only CP/M in mind, would not have permitted
extensions to current areas of personal computing such as Unix, DOS, and
object oriented systems.

As in the case of single a file transfer, the receiver initiates batch
file transmission by sending a "C" character (for CRC-16).

The sender opens the first file and sends packet number 0 with the


XMODEM/YMODEM Protocol Reference                                         7








                                  - 8 -
XMODEM Protocol Enhancements                                     Chapter 3


following information.1

Only the pathname (file name) part is required for batch transfers.

To maintain upwards compatibility, all unused bytes in packet 0 must be
set to null.

Pathname The pathname (conventionally, the file name) is sent as a null
     terminated ASCII string.  This is the filename format used by the
     handle oriented MSDOS(TM) functions and C library fopen functions.
     An assembly language example follows:
                              DB      'foo.bar',0
     No spaces are included in the pathname.  Normally only the file name
     stem (no directory prefix) is transmitted unless the sender has
     selected YAM's f option to send the full pathname.  The source drive
     (A:, B:, etc.) is not sent.

     Filename Considerations:

        + File names should be translated to lower case unless the sending
          system supports upper/lower case file names.  This is a
          convenience for users of systems (such as Unix) which store
          filenames in upper and lower case.

        + The receiver should accommodate file names in lower and upper
          case.

        + The rb(1) program on Unix systems normally translates the
          filename to lower case unless one or more letters in the
          filename are already in lower case.

        + When transmitting files between different operating systems,
          file names must be acceptable to both the sender and receiving
          operating systems.
     If directories are included, they are delimited by /; i.e.,
     "subdir/foo" is acceptable, "subdir\foo" is not.

Length The file length and each of the succeeding fields are optional.2
     The length field is stored in the packet as a decimal string.  The
     file length does not include any CPMEOF (^Z) characters used to pad
     the last packet.

     If the file being transmitted is growing during transmission, the


__________

 1. Only the data part of the packet is described here.

 2. Fields may not be skipped.



8                           Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 9 -
Chapter 3                                     XMODEM Protocol Enhancements


     length field should be set to at least the final expected file
     length, or not sent.

     The receiver stores the specified number of characters, discarding
     any padding added by the sender to fill up the last packet.

Mod Date A single space separates the modification date from the file
     length.

     The mod date is optional, and the filename and length may be sent
     without requiring the mod date to be sent.

     The mod date is sent as an octal number giving the time the contents
     of the file were last changed measured in seconds from Jan 1 1970
     Universal Coordinated Time (GMT).  A date of 0 implies the
     modification date is unknown and should be left as the date the file
     is received.

     This standard format was chosen to eliminate ambiguities arising from
     transfers between different time zones.

     Two Microsoft blunders complicate the use of modification dates in
     file transfers with MSDOS(TM) systems.  The first is the lack of
     timezone standardization in MS-DOS.  A file's creation time can not
     be known unless the timezone of the system that happened to write the
     file3 is known.  Unix solved this problem (for planet Earth, anyway)
     by stamping files with Universal Time (GMT).  Microsoft would have to
     include the timezone of origin in the directory entries, but does
     not.  YAM gets around this problem by using the z parameter which is
     set to the number of minutes local time lags GMT.  For files known to
     originate from a different timezone, the -zT option may be used use T
     as the timezone for an individual file transfer.

     The second problem is the lack of a separate file creation date in
     DOS.  Since some backup schemes used with DOS rely on the file
     creation date to select files to be copied to the archive, back-
     dating the file modification date could interfere with the safety of
     the transferred files.  For this reason, Professional-YAM does not
     modify the date of received files with the header information unless
     the d parameter is non zero.


Mode A single space separates the file mode from the modification date.
     The file mode is stored as an octal string.  Unless the file
     originated from a Unix system, the file mode is set to 0.  rb(1)


__________

 3. Not necessarily that of the transmitting system!



XMODEM/YMODEM Protocol Reference                                         9








                                  - 10 -
XMODEM Protocol Enhancements                                     Chapter 3


     checks the file mode for the 0x8000 bit which indicates a Unix type
     regular file.  Files with the 0x8000 bit set are assumed to have been
     sent from another Unix (or similar) system which uses the same file
     conventions.  Such files are not translated in any way.


Serial Number A single space separates the serial number from the file
     mode.  The serial number of the transmitting program is stored as an
     octal string.  Programs which do not have a serial number should omit
     this field, or set it to 0.  The receiver's use of this field is
     optional.

The rest of the packet is set to nulls.  This is essential to preserve
upward compatibility.4 After the filename packet has been received, it is
ACK'ed if the write open is successful.  The receiver then initiates
transfer of the file contents according to the standard XMODEM/CRC
protocol.  If the file cannot be opened for writing, the receiver cancels
the transfer with CAN characters as described above.

After the file contents have been transmitted, the receiver again asks for
the next pathname.  Transmission of a null pathname terminates batch file
transmission.  Note that transmission of no files is not necessarily an
error.  This is possible if none of the files requested of the sender
could be opened for reading.

In batch transmission, the receiver automatically requests CRC-16.

The Unix programs sb(1) and rb(1) included in the source code file
RBSB.QQQ (rbsb.sh) should answer questions about YAM's batch protocol.
















__________

 4. If, perchance, this information extends beyond 128 bytes (possible
    with Unix 4.2 BSD extended file names), the packet should be sent as a
    1k packet as described above.



10                          Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 11 -
Chapter 4                                         Xmodem Protocol Overview


            Figure 3.  Batch Transmission Session
            SENDER                                  RECEIVER
                                                    "sb foo.*"
            "sending in batch mode etc."
                                                    C
            SOH 00 FF foo.c NUL[123] CRC CRC
                                                    ACK
                                                    C
            SOH 01 FE Data[128] CRC CRC
                                                    ACK
            SOH 02 FD Data[1024] CRC CRC
                                                    ACK
            SOH 03 FC Data[128] CRC CRC
                                                    ACK
            SOH 04 FB Data[100] CPMEOF[28] CRC CRC
                                                    ACK
            EOT
                                                    ACK
                                                    C
            SOH 00 FF NUL[128] CRC CRC
                                                    ACK

       Figure 4.  Filename packet transmitted by sb

                    -rw-r--r--  6347 Jun 17 1984 20:34 bbcsched.txt

       00 0100FF62 62637363 6865642E 74787400   |...bbcsched.txt.|
       10 36333437 20333331 34373432 35313320   |6347 3314742513 |
       20 31303036 34340000 00000000 00000000   |100644..........|
       30 00000000 00000000 00000000 00000000
       80 000000CA 56

4.  XMODEM PROTOCOL OVERVIEW

8/9/82 by Ward Christensen.

I will maintain a master copy of this.  Please pass on changes or
suggestions via CBBS/Chicago at (312) 545-8086, CBBS/CPMUG (312) 849-1132
or by voice at (312) 849-6279.

4.1  Definitions

  <soh> 01H
  <eot> 04H
  <ack> 06H
  <nak> 15H
  <can> 18H
  <C>   43H





XMODEM/YMODEM Protocol Reference                                        11








                                  - 12 -
Xmodem Protocol Overview                                         Chapter 4


4.2  Transmission Medium Level Protocol

Asynchronous, 8 data bits, no parity, one stop bit.

The protocol imposes no restrictions on the contents of the data being
transmitted.  No control characters are looked for in the 128-byte data
messages.  Absolutely any kind of data may be sent - binary, ASCII, etc.
The protocol has not formally been adopted to a 7-bit environment for the
transmission of ASCII-only (or unpacked-hex) data , although it could be
simply by having both ends agree to AND the protocol-dependent data with
7F hex before validating it.  I specifically am referring to the checksum,
and the block numbers and their ones- complement.

Those wishing to maintain compatibility of the CP/M file structure, i.e.
to allow modemming ASCII files to or from CP/M systems should follow this
data format:

   + ASCII tabs used (09H); tabs set every 8.

   + Lines terminated by CR/LF (0DH 0AH)

   + End-of-file indicated by ^Z, 1AH.  (one or more)

   + Data is variable length, i.e. should be considered a continuous
     stream of data bytes, broken into 128-byte chunks purely for the
     purpose of transmission.

   + A CP/M "peculiarity": If the data ends exactly on a 128-byte
     boundary, i.e. CR in 127, and LF in 128, a subsequent sector
     containing the ^Z EOF character(s) is optional, but is preferred.
     Some utilities or user programs still do not handle EOF without ^Zs.

   + The last block sent is no different from others, i.e.  there is no
     "short block".

              Figure 5.  XMODEM Message Block Level Protocol

      Each block of the transfer looks like:
     <SOH><blk #><255-blk #><--128 data bytes--><cksum>
         in which:
     <SOH>       = 01 hex
     <blk #>     = binary number, starts at 01 increments by 1, and
                   wraps 0FFH to 00H (not to 01)
     <255-blk #> = blk # after going thru 8080 "CMA" instr, i.e.
                   each bit complemented in the 8-bit block number.
                   Formally, this is the "ones complement".
     <cksum>     = the sum of the data bytes only.  Toss any carry.






12                          Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 13 -
Chapter 4                                         Xmodem Protocol Overview


4.3  File Level Protocol

4.3.1  Common_to_Both_Sender_and_Receiver
All errors are retried 10 times.  For versions running with an operator
(i.e. NOT with XMODEM), a message is typed after 10 errors asking the
operator whether to "retry or quit".

Some versions of the protocol use <can>, ASCII ^X, to cancel transmission.
This was never adopted as a standard, as having a single "abort" character
makes the transmission susceptible to false termination due to an <ack>
<nak> or <soh> being corrupted into a <can> and cancelling transmission.

The protocol may be considered "receiver driven", that is, the sender need
not automatically re-transmit, although it does in the current
implementations.


4.3.2  Receive_Program_Considerations
The receiver has a 10-second timeout.  It sends a <nak> every time it
times out.  The receiver's first timeout, which sends a <nak>, signals the
transmitter to start.  Optionally, the receiver could send a <nak>
immediately, in case the sender was ready.  This would save the initial 10
second timeout.  However, the receiver MUST continue to timeout every 10
seconds in case the sender wasn't ready.

Once into a receiving a block, the receiver goes into a one-second timeout
for each character and the checksum.  If the receiver wishes to <nak> a
block for any reason (invalid header, timeout receiving data), it must
wait for the line to clear.  See "programming tips" for ideas

Synchronizing:  If a valid block number is received, it will be: 1) the
expected one, in which case everything is fine; or 2) a repeat of the
previously received block.  This should be considered OK, and only
indicates that the receivers <ack> got glitched, and the sender re-
transmitted; 3) any other block number indicates a fatal loss of
synchronization, such as the rare case of the sender getting a line-glitch
that looked like an <ack>.  Abort the transmission, sending a <can>


4.3.3  Sending_program_considerations
While waiting for transmission to begin, the sender has only a single very
long timeout, say one minute.  In the current protocol, the sender has a
10 second timeout before retrying.  I suggest NOT doing this, and letting
the protocol be completely receiver-driven.  This will be compatible with
existing programs.

When the sender has no more data, it sends an <eot>, and awaits an <ack>,
resending the <eot> if it doesn't get one.  Again, the protocol could be
receiver-driven, with the sender only having the high-level 1-minute
timeout to abort.



XMODEM/YMODEM Protocol Reference                                        13








                                  - 14 -
Xmodem Protocol Overview                                         Chapter 4


Here is a sample of the data flow, sending a 3-block message.  It includes
the two most common line hits - a garbaged block, and an <ack> reply
getting garbaged.  <xx> represents the checksum byte.


       Figure 6.  Data flow including Error Recovery

       SENDER                                  RECEIVER
                                       times out after 10 seconds,
                               <---            <nak>
       <soh> 01 FE -data- <xx> --->
                               <---            <ack>
       <soh> 02 FD -data- xx   --->    (data gets line hit)
                               <---            <nak>
       <soh> 02 FD -data- xx   --->
                               <---            <ack>
       <soh> 03 FC -data- xx   --->
          (ack gets garbaged)  <---            <ack>
       <soh> 03 FC -data- xx   --->            <ack>
       <eot>                   --->
                               <---            <ack>

4.4  Programming Tips

   + The character-receive subroutine should be called with a parameter
     specifying the number of seconds to wait.  The receiver should first
     call it with a time of 10, then <nak> and try again, 10 times.

     After receiving the <soh>, the receiver should call the character
     receive subroutine with a 1-second timeout, for the remainder of the
     message and the <cksum>.  Since they are sent as a continuous stream,
     timing out of this implies a serious like glitch that caused, say,
     127 characters to be seen instead of 128.

   + When the receiver wishes to <nak>, it should call a "PURGE"
     subroutine, to wait for the line to clear.  Recall the sender tosses
     any characters in its UART buffer immediately upon completing sending
     a block, to ensure no glitches were mis- interpreted.

     The most common technique is for "PURGE" to call the character
     receive subroutine, specifying a 1-second timeout,1 and looping back
     to PURGE until a timeout occurs.  The <nak> is then sent, ensuring
     the other end will see it.




__________

 1. These times should be adjusted for use with timesharing systems.



14                          Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 15 -
Chapter 4                                         Xmodem Protocol Overview


   + You may wish to add code recommended by John Mahr to your character
     receive routine - to set an error flag if the UART shows framing
     error, or overrun.  This will help catch a few more glitches - the
     most common of which is a hit in the high bits of the byte in two
     consecutive bytes.  The <cksum> comes out OK since counting in 1-byte
     produces the same result of adding 80H + 80H as with adding 00H +
     00H.














































XMODEM/YMODEM Protocol Reference                                        15








                                  - 16 -
Xmodem Protocol Overview                                         Chapter 5


5.  XMODEM/CRC Overview

1/13/85 by John Byrns -- CRC option.

Please pass on any reports of errors in this document or suggestions for
improvement to me via Ward's/CBBS at (312) 849-1132, or by voice at (312)
885-1105.

The CRC used in the Modem Protocol is an alternate form of block check
which provides more robust error detection than the original checksum.
Andrew S. Tanenbaum says in his book, Computer Networks, that the CRC-
CCITT used by the Modem Protocol will detect all single and double bit
errors, all errors with an odd number of bits, all burst errors of length
16 or less, 99.997% of 17-bit error bursts, and 99.998% of 18-bit and
longer bursts.

The changes to the Modem Protocol to replace the checksum with the CRC are
straight forward. If that were all that we did we would not be able to
communicate between a program using the old checksum protocol and one
using the new CRC protocol. An initial handshake was added to solve this
problem. The handshake allows a receiving program with CRC capability to
determine whether the sending program supports the CRC option, and to
switch it to CRC mode if it does. This handshake is designed so that it
will work properly with programs which implement only the original
protocol. A description of this handshake is presented in section 10.

  Figure 7.  Message Block Level Protocol, CRC mode

  Each block of the transfer in CRC mode looks like:

  <SOH><blk #><255-blk #><--128 data bytes--><CRC hi><CRC lo>
      in which:
  <SOH>             = 01 hex
  <blk #>     = binary number, starts at 01 increments by 1, and
                wraps 0FFH to 00H (not to 01)
  <255-blk #> = ones complement of blk #.
  <CRC hi>    = byte containing the 8 hi order coefficients of the CRC.
  <CRC lo>    = byte containing the 8 lo order coefficients of the CRC.
                See the next section for CRC calculation.

5.1  CRC Calculation

5.1.1  Formal_Definition
To calculate the 16 bit CRC the message bits are considered to be the
coefficients of a polynomial. This message polynomial is first multiplied
by X^16 and then divided by the generator polynomial (X^16 + X^12 + X^5 +
1) using modulo two arithemetic. The remainder left after the division is
the desired CRC. Since a message block in the Modem Protocol is 128 bytes
or 1024 bits, the message polynomial will be of order X^1023. The hi order
bit of the first byte of the message block is the coefficient of X^1023 in
the message polynomial.  The lo order bit of the last byte of the message


16                          Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 17 -
Chapter 5                                         Xmodem Protocol Overview


block is the coefficient of X^0 in the message polynomial.


   Figure 8.  Example of CRC Calculation written in C

   /*
    * This function calculates the CRC used by the XMODEM/CRC Protocol
    * The first argument is a pointer to the message block.
    * The second argument is the number of bytes in the message block.
    * The function returns an integer which contains the CRC.
    * The low order 16 bits are the coefficients of the CRC.
    */

   int calcrc(ptr, count)
   char *ptr;
   int count;
   {
       int crc, i;

       crc = 0;
       while(--count >= 0) {
           crc = crc ^ (int)*ptr++ << 8;
           for(i = 0; i < 8; ++i)
               if(crc & 0x8000)
                   crc = crc << 1 ^ 0x1021;
               else
                   crc = crc << 1;
           }
       return (crc & 0xFFFF);
   }

5.2  CRC File Level Protocol Changes

5.2.1  Common_to_Both_Sender_and_Receiver
The only change to the File Level Protocol for the CRC option is the
initial handshake which is used to determine if both the sending and the
receiving programs support the CRC mode. All Modem Programs should support
the checksum mode for compatibility with older versions.  A receiving
program that wishes to receive in CRC mode implements the mode setting
handshake by sending a <C> in place of the initial <nak>.  If the sending
program supports CRC mode it will recognize the <C> and will set itself
into CRC mode, and respond by sending the first block as if a <nak> had
been received. If the sending program does not support CRC mode it will
not respond to the <C> at all. After the receiver has sent the <C> it will
wait up to 3 seconds for the <soh> that starts the first block. If it
receives a <soh> within 3 seconds it will assume the sender supports CRC
mode and will proceed with the file exchange in CRC mode. If no <soh> is
received within 3 seconds the receiver will switch to checksum mode, send
a <nak>, and proceed in checksum mode. If the receiver wishes to use
checksum mode it should send an initial <nak> and the sending program
should respond to the <nak> as defined in the original Modem Protocol.


XMODEM/YMODEM Protocol Reference                                        17








                                  - 18 -
Xmodem Protocol Overview                                         Chapter 5


After the mode has been set by the initial <C> or <nak> the protocol
follows the original Modem Protocol and is identical whether the checksum
or CRC is being used.


5.2.2  Receive_Program_Considerations
There are at least 4 things that can go wrong with the mode setting
handshake.

  1.  the initial <C> can be garbled or lost.

  2.  the initial <soh> can be garbled.

  3.  the initial <C> can be changed to a <nak>.

  4.  the initial <nak> from a receiver which wants to receive in checksum
      can be changed to a <C>.

The first problem can be solved if the receiver sends a second <C> after
it times out the first time. This process can be repeated several times.
It must not be repeated too many times before sending a <nak> and
switching to checksum mode or a sending program without CRC support may
time out and abort. Repeating the <C> will also fix the second problem if
the sending program cooperates by responding as if a <nak> were received
instead of ignoring the extra <C>.

It is possible to fix problems 3 and 4 but probably not worth the trouble
since they will occur very infrequently. They could be fixed by switching
modes in either the sending or the receiving program after a large number
of successive <nak>s. This solution would risk other problems however.


5.2.3  Sending_Program_Considerations
The sending program should start in the checksum mode. This will insure
compatibility with checksum only receiving programs. Anytime a <C> is
received before the first <nak> or <ack> the sending program should set
itself into CRC mode and respond as if a <nak> were received. The sender
should respond to additional <C>s as if they were <nak>s until the first
<ack> is received. This will assist the receiving program in determining
the correct mode when the <soh> is lost or garbled. After the first <ack>
is received the sending program should ignore <C>s.


5.3  Data Flow Examples with CRC Option

Here is a data flow example for the case where the receiver requests
transmission in the CRC mode but the sender does not support the CRC
option. This example also includes various transmission errors.  <xx>
represents the checksum byte.




18                          Vsn 13.09 05-05-85              TurboDial 1.02








                                  - 19 -
Chapter 5                                         Xmodem Protocol Overview


      Figure 9.  Data Flow: Receiver has CRC Option, Sender Doesn't

      SENDER                                  RECEIVER
                              <---            <C>
                                      times out after 3 seconds,
                              <---            <nak>
      <soh> 01 FE -data- <xx> --->
                              <---            <ack>
      <soh> 02 FD -data- <xx> --->    (data gets line hit)
                              <---            <nak>
      <soh> 02 FD -data- <xx> --->
                              <---            <ack>
      <soh> 03 FC -data- <xx> --->
         (ack gets garbaged)  <---            <ack>
                                      times out after 10 seconds,
                              <---            <nak>
      <soh> 03 FC -data- <xx> --->
                              <---            <ack>
      <eot>                   --->
                              <---            <ack>

Here is a data flow example for the case where the receiver requests
transmission in the CRC mode and the sender supports the CRC option.  This
example also includes various transmission errors.  <xxxx> represents the
2 CRC bytes.

           Figure 10.  Receiver and Sender Both have CRC Option

     SENDER                                    RECEIVER
                               <---            <C>
     <soh> 01 FE -data- <xxxx> --->
                               <---            <ack>
     <soh> 02 FD -data- <xxxx> --->    (data gets line hit)
                               <---            <nak>
     <soh> 02 FD -data- <xxxx> --->
                               <---            <ack>
     <soh> 03 FC -data- <xxxx> --->
        (ack gets garbaged)    <---            <ack>
                                       times out after 10 seconds,
                               <---            <nak>
     <soh> 03 FC -data- <xxxx> --->
                               <---            <ack>
     <eot>                     --->
                               <---            <ack>









XMODEM/YMODEM Protocol Reference                                        19








                                  - 20 -
Xmodem Protocol Overview                                         Chapter 5


Technical questions about Professional-YAM and requests for evaluation
copies for magazine reviews may be directed to:
     Chuck Forsberg
     Omen Technology Inc
     17505-V Sauvie Island Road
     Portland Oregon 97231
     Voice: 503-621-3406
     Modem: 503-621-3746 Speed: 1200,300
     Compuserve: 70715,131
     Source: TCE022
More information about Professional-YAM may be obtained by calling
Telegodzilla at 503-621-3746.  Hit RETURNs for baud rate detection.









































20                          Vsn 13.09 05-05-85              TurboDial 1.02












                                 CONTENTS


1.  TOWER OF BABEL ??.................................................   2
    1.1  Some Messages from the Pioneer...............................   2

2.  XMODEM PROTOCOL ENHANCEMENTS......................................   5
    2.1  CAN-CAN Abort................................................   5
    2.2  CRC-16 Option................................................   5
    2.3  1024 Byte Packet Option......................................   6

3.  YMODEM Batch File Transmission....................................   7

4.  XMODEM PROTOCOL OVERVIEW..........................................  11
    4.1  Definitions..................................................  11
    4.2  Transmission Medium Level Protocol...........................  12
    4.3  File Level Protocol..........................................  13
    4.4  Programming Tips.............................................  14

5.  XMODEM/CRC Overview...............................................  16
    5.1  CRC Calculation..............................................  16
    5.2  CRC File Level Protocol Changes..............................  17
    5.3  Data Flow Examples with CRC Option...........................  18































                                  - i -














                             LIST OF FIGURES


 Figure 1.  1024 byte Packets.........................................   6

 Figure 2.  Mixed 1024 and 128 byte Packets...........................   6

 Figure 3.  Batch Transmission Session................................  10

 Figure 4.  Filename packet transmitted by sb.........................  10

 Figure 5.  XMODEM Message Block Level Protocol.......................  12

 Figure 6.  Data flow including Error Recovery........................  14

 Figure 7.  Message Block Level Protocol, CRC mode....................  16

 Figure 8.  Example of CRC Calculation written in C...................  17

 Figure 9.  Data Flow: Receiver has CRC Option, Sender Doesn't........  18

Figure 10.  Receiver and Sender Both have CRC Option..................  19





























                                  - ii -




                                                                          

                                  - ii -




                                                                                                                                                                                                          