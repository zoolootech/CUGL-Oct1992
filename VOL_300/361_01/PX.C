
/* PX.C  --> A Pipe Extension Tool.  14 April 89
 *
 * Author: Jack Ekwall.
 *
 * Works Better if You Compile w/o WildCard Expansion.
 *
 * Copyrighted to the Public Domain.  Unlimited Distribution Autorized.
 *
 * User Assumes All Risks/Liabilities.
 *
 * Last Update:  7 August 90/EK
 *
 */

#include <stdio.h>
#include <io.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdek.h>
#include <string.h>

char *Documentation[] = {
    "",
"Usage:",
"       PX [options] [Command [Arguements] or $Pipe]  --> Extend DOS Piping.",
    "",
"Option Flags are Required in .BAT Files:",
"         /A ---> Append to Specified Pipe.",
"         /R ---> Read From Specified Pipe.  [Force OutFlow]",
"         /W ---> Write to Specified Pipe.",
    "",
"Pipes:",
"    1. PX \"Pipe Extends\" DOS stdin/stdout Pipes using ordinary Files w/ ",
"       Unusual Names.  These Names can not be Generated by DOS.",
"    2. A \"Named\" Pipe name is 1-4 Alphanumeric Characters Preceeded by '$'.",
    "",
"Action:",
"    1. If InFlow Redirection, Create the Specified $Pipe ($IN is Default).",
"    2. If a Command is Passed in, Shells Out & Execute it.",
"    3. If Redirected to a File/DOS Pipe, Print Contents of Specified $Pipe.",
"         (Default is $OUT if found, otherwise $IN).",
"    4. PX erases $Pipe after reading.",
    NULL};

/* Declare Prototypes */
void Stream(FILE *,FILE *);
void Usage(void);

/* Declare Globals */
FILE *fp;

main (int argc, char *argv[])
{
    int c, i, CleanUp, Mode = -1;
    char CmdLine[128], *In_Flag,  Name[80], *tp1;

 /* Set Option Flags */
    In_Flag = "w";
    while (*argv[1] IS SLASH) {
       for (tp1 = argv[1] + 1; *tp1 != NULL; tp1++) {
          switch (toupper(*tp1)) {
          case 'A': In_Flag = "a"; Mode = 1; break;
          case 'R': Mode = 2; break;
          case 'W': Mode = 1; break;
          }
       }

    /* SHIFT */
       for (i = 1, --argc; i <= argc + 1; i++) argv[i] = argv[i+1];
    }

 /* Determine Operating Mode */
    if (INFLOW_EXISTS && open("\\STD ERR", 1) >= 0) exit(1);
    unlink("\\STD ERR");
    if (Mode < 0) Mode = INFLOW_EXISTS + 2*(OUTFLOW_EXISTS);
    if (argc > 1 && *argv[1] != '$') Mode += 4;

    switch (Mode) {
    case 0: Usage(); break;     /* Barefoot */
    case 2:                     /* OutFlow Only */
    case 3:                     /* Both InFlow & OutFlow (Ignore InFlow) */
       if (argc > 1 && *argv[1] IS '$') {
          strcpy(Name,"\\STD ");strcat(Name,++argv[1]);
          if ((fp = fopen(Name,"r")) IS NULL) { perror(Name); exit(1); }
          CleanUp = FALSE;
       } else {
          strcpy(Name,"\\STD OUT");
          if ((fp = fopen(Name,"r")) IS NULL) {
             strcpy(Name,"\\STD IN");
             if ((fp = fopen(Name,"r")) IS NULL) Usage();
          }
          CleanUp = TRUE;
       }
       Stream(fp,stdout); unlink(Name);
       if (CleanUp) { unlink("\\STD IN"); unlink("\\STD OUT"); }
       exit(0);
    case 1:                     /* InFlow Only */
    default:                    /* InFlow w/ Command Text */
       if (argc > 1 && *argv[1] IS '$') {
          strcpy(Name,"\\STD ");strcat(Name,++argv[1]);
          if ((fp = fopen(Name,In_Flag)) IS NULL) { perror(Name); exit(1); }
       } else {
          unlink("\\STD IN"); strcpy(Name,"\\STD OUT");
          if ((fp = fopen(Name,In_Flag)) IS NULL) { perror(Name); exit(1); }
       }
       Stream(stdin,fp);
       if (Mode IS 1) exit(0);
    case 4:                     /* Shell Out & Execute Something */
    case 6:                     /* OutFlow w/ Command Text */
       rename("\\STD OUT","\\STD IN");
       for (i = 1, *CmdLine = NULL; i < argc; i++) {
          strcat(CmdLine,argv[i]); strcat(CmdLine," "); }
       while ((tp1 = strchr(CmdLine,BANG)) != NULL) *tp1 = BAR;
       while ((tp1 = strchr(CmdLine,DIT)) != NULL) *tp1 = QUOTE;
       system(CmdLine); unlink("\\STD IN");
       exit(0);
    }
}

void Stream(FILE *fp1, FILE *fp2)
{
    int c;

    while ((c = getc(fp1)) != EOF) if (c) putc(c,fp2);
    fclose(fp);
}


void Usage(void)
{
    char   **dp = Documentation;

    for ( ; *dp; dp++) fprintf(stderr,"%s\n", *dp);
    exit(1);
}
