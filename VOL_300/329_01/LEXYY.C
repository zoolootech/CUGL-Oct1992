#define YY_DEFAULT_ACTION ECHO;
#define FLEX_USE_ECS
#define FLEX_USE_MECS
/* A lexical scanner generated by flex */

#include "skeleton.h"

# line 1 "csubst.l"
#define INITIAL 0
/* csubst.l */
/* lex source of csubst utility.
This programme is shareware.
If you found this programme useful then send me a colourful postcard
with the words "Happy Birthday" (or equivalent) so that it arrives
at my address around the first of January 1991.

Henri de Feraudy
27 rue Chef de Ville
92140 Clamart 
France
*/
# line 14 "csubst.l"
extern int  Mode, Truncation;
extern char *lookup_subst();
#include <stdio.h>
#include "csubst.h"
#define cond_putchar(C) if(Mode == APPLY_SUBSTS || Mode == PRINT_TRUNCATED)putchar(C);

#ifdef yywrap
#undef yywrap
#define yywrap() (!next_yyin())
#endif

void action_keyword(), default_action(), action_symbol(), read_comment();
#define CPP_MACRO 2
# line 37 "csubst.l"
#define YY_JAM 335
#define YY_JAM_BASE 414
#define YY_TEMPLATE 336
static char l[336] =
    {   0,
       -2,   -2,   -2,   -2,   44,   42,   44,   44,   44,   44,
       44,   41,   41,   41,   41,   41,   41,   41,   41,   41,
       41,   41,   41,   41,   41,   41,   41,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,    0,   38,    0,    0,    5,    5,    5,
        0,    0,    1,    0,   41,   41,   41,   41,   41,   41,
       41,   13,   41,   41,   41,   41,   41,   41,   21,   41,
       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
       40,   40,   40,   40,   40,   40,   40,   13,   40,   40,
       40,   40,   40,   40,   21,   40,   40,   40,   40,   40,

       40,   40,   40,   40,   40,   40,    5,    5,    5,    5,
       39,   43,   41,   41,   41,   41,   41,   41,   41,   41,
       41,   41,   41,   19,   41,   22,   41,   41,   41,   41,
       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
       41,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   19,   40,   22,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
        5,    5,    5,    5,    6,   41,    8,    9,   41,   41,
       41,   41,   15,   16,   41,   41,   20,   23,   41,   41,
       41,   41,   41,   41,   41,   41,   41,   41,   41,   35,

       41,   41,    6,   40,    8,    9,   40,   40,   40,   40,
       15,   16,   40,   40,   20,   23,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   35,   40,   40,
        5,    5,    5,    5,    7,   10,   41,   41,   41,   41,
       18,   41,   41,   26,   41,   41,   41,   41,   41,   41,
       33,   41,   41,   37,    7,   10,   40,   40,   40,   40,
       18,   40,   40,   26,   40,   40,   40,   40,   40,   40,
       33,   40,   40,   37,    5,    3,    5,    5,   41,   41,
       14,   17,   41,   25,   27,   28,   29,   30,   31,   41,
       41,   41,   40,   40,   14,   17,   40,   25,   27,   28,

       29,   30,   31,   40,   40,   40,    4,    5,   41,   12,
       41,   32,   41,   41,   40,   12,   40,   32,   40,   40,
        4,    5,   11,   24,   34,   36,   11,   24,   34,   36,
        0,    0,    0,    2,    0
    } ;

static char e[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    1,    1,    1,    6,    1,
        1,    7,    1,    1,    1,    8,    9,   10,   11,   11,
       11,   11,   11,   11,   11,   11,   11,    1,    1,   12,
        1,   13,    1,    1,   14,   14,   14,   14,   14,   14,
       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
        1,   16,    1,    1,   17,    1,   18,   19,   20,   21,

       22,   23,   24,   25,   26,   15,   27,   28,   29,   30,
       31,   32,   15,   33,   34,   35,   36,   37,   38,   39,
       40,   41,    1,    1,    1,    1,    1
    } ;

static char m[42] =
    {   0,
        1,    2,    1,    1,    1,    3,    1,    4,    4,    5,
        5,    1,    1,    6,    7,    4,    8,    6,    6,    6,
        6,    6,    6,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7
    } ;

static short int b[344] =
    {   0,
        0,    0,   41,    0,  414,  414,   79,   82,  398,  406,
      373,    0,  375,  377,   67,   65,   58,   62,  378,   71,
      377,  385,   74,  366,  375,  373,  378,    0,  366,  368,
       86,   83,   85,   79,  369,   93,  368,  376,   93,  357,
      366,  364,  369,  116,  414,  390,  100,    0,  370,   99,
      119,  124,  414,    0,    0,  356,  368,  355,  370,  357,
      363,  349,  350,  347,  347,  350,  347,  344,    0,  343,
      347,  109,  345,   65,  116,  349,  342,  111,  110,  347,
        0,  337,  349,  336,  351,  338,  344,  330,  331,  328,
      328,  331,  328,  325,    0,  324,  328,  115,  326,  116,

      123,  330,  323,  117,  120,  328,    0,  330,  131,  332,
      414,  414,  320,  332,  327,  315,  119,  329,  327,  323,
      315,  321,  324,    0,  310,    0,  316,  313,  302,  304,
      306,  313,  299,  297,  297,  309,  299,  303,  307,  309,
      298,  294,  306,  301,  289,  124,  303,  301,  297,  289,
      295,  298,    0,  284,    0,  290,  287,  276,  278,  280,
      287,  273,  271,  271,  283,  273,  277,  281,  283,  272,
      273,  276,  276,  268,    0,  268,    0,    0,  259,  267,
      256,  263,    0,    0,  257,  254,    0,    0,  254,  254,
      251,  263,  253,  257,  262,  261,  259,  249,  254,    0,

      242,  254,    0,  248,    0,    0,  239,  247,  236,  243,
        0,    0,  237,  234,    0,    0,  234,  234,  231,  243,
      233,  237,  242,  241,  239,  229,  234,    0,  222,  234,
      225,  231,  231,  216,    0,    0,  221,  222,  227,  218,
        0,  212,  216,    0,  224,  221,  223,  207,  216,  218,
        0,  209,  212,    0,    0,    0,  207,  208,  213,  204,
        0,  198,  202,    0,  210,  207,  209,  193,  202,  204,
        0,  195,  198,    0,  201,    0,  199,  200,  184,  184,
        0,    0,  196,    0,    0,    0,    0,    0,    0,  194,
      194,  187,  178,  178,    0,    0,  190,    0,    0,    0,

        0,    0,    0,  188,  165,  154,  179,  158,  147,    0,
      135,    0,  146,  144,  142,    0,  130,    0,  141,  125,
      140,  153,    0,    0,    0,    0,    0,    0,    0,    0,
      158,    0,   78,  414,  414,  170,  177,  184,  188,  192,
      196,  200,  203
    } ;

static short int d[344] =
    {   0,
      335,    1,  335,    3,  335,  335,  336,  337,  338,  335,
      335,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  336,  335,  336,  337,  341,  341,  341,
      338,  338,  335,  342,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,

      340,  340,  340,  340,  340,  340,  341,  341,  341,  341,
      335,  335,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      341,  341,  341,  341,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,

      339,  339,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      341,  341,  341,  341,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  339,  339,  339,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  341,  341,  341,  341,  339,  339,
      339,  339,  339,  339,  339,  339,  339,  339,  339,  339,
      339,  339,  340,  340,  340,  340,  340,  340,  340,  340,

      340,  340,  340,  340,  340,  340,  341,  341,  339,  339,
      339,  339,  339,  339,  340,  340,  340,  340,  340,  340,
      335,  341,  339,  339,  339,  339,  340,  340,  340,  340,
      335,  343,  343,  335,-32767,  335,  335,  335,  335,  335,
      335,  335,  335
    } ;

static short int n[456] =
    {   0,
        5,    5,    6,    7,    8,    9,    5,    5,   10,   11,
        5,    5,    5,   12,   12,    5,    5,   13,   14,   15,
       16,   17,   18,   19,   12,   20,   12,   21,   12,   12,
       12,   12,   22,   23,   24,   25,   26,   27,   12,   12,
       12,    5,    5,    6,    7,    8,    9,    5,    5,   10,
       11,    5,    5,    5,   28,   28,    5,    5,   29,   30,
       31,   32,   33,   34,   35,   28,   36,   28,   37,   28,
       28,   28,   28,   38,   39,   40,   41,   42,   43,   28,
       28,   28,   45,   47,   58,   63,   61,   64,  131,   66,
      334,   59,   67,   69,   46,   62,   65,   60,   73,   74,

       70,   47,   49,   84,   87,  132,   92,   50,   75,   93,
       85,   76,   89,   88,   90,   95,   86,   99,  100,   45,
       49,  109,   96,   91,  111,   50,  335,  101,  110,   51,
      102,   46,  128,  133,   52,  139,  137,  140,  157,  160,
      162,  321,  166,  129,  138,  168,  330,  169,  134,  158,
      167,  172,  179,  180,  331,  163,  161,  207,  208,  331,
      173,  329,  328,  327,  332,  326,  325,  324,  323,  332,
       44,   44,   44,   44,   44,   44,   44,   44,   48,  322,
      321,  320,   48,   48,   51,   51,  319,   51,   51,   51,
       51,   51,   55,   55,   55,   55,   81,   81,   81,   81,

      107,  107,  107,  107,  112,  112,  333,  333,  333,  333,
      318,  317,  316,  315,  314,  313,  312,  311,  310,  309,
      308,  276,  307,  306,  305,  304,  303,  302,  301,  300,
      299,  298,  297,  296,  295,  294,  293,  292,  291,  290,
      289,  288,  287,  286,  285,  284,  283,  282,  281,  280,
      279,  278,  277,  276,  275,  274,  273,  272,  271,  270,
      269,  268,  267,  266,  265,  264,  263,  262,  261,  260,
      259,  258,  257,  256,  255,  254,  253,  252,  251,  250,
      249,  248,  247,  246,  245,  244,  243,  242,  241,  240,
      239,  238,  237,  236,  235,  234,  233,  232,  231,  230,

      229,  228,  227,  226,  225,  224,  223,  222,  221,  220,
      219,  218,  217,  216,  215,  214,  213,  212,  211,  210,
      209,  206,  205,  204,  203,  202,  201,  200,  199,  198,
      197,  196,  195,  194,  193,  192,  191,  190,  189,  188,
      187,  186,  185,  184,  183,  182,  181,  178,  177,  176,
      175,  174,  171,  170,  165,  164,  159,  156,  155,  154,
      153,  152,  151,  150,  149,  148,  147,  146,  145,  144,
      143,  142,  141,  136,  135,  130,  127,  126,  125,  124,
      123,  122,  121,  120,  119,  118,  117,  116,  115,  114,
      113,  108,  335,  106,  105,  104,  103,   98,   97,   94,

       83,   82,   80,   79,   78,   77,   72,   71,   68,   57,
       56,   54,   53,   52,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335
    } ;

static short int c[456] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    7,    8,   15,   17,   16,   17,   74,   18,
      333,   15,   18,   20,    7,   16,   17,   15,   23,   23,

       20,   47,    8,   31,   32,   74,   34,    8,   23,   34,
       31,   23,   33,   32,   33,   36,   31,   39,   39,   44,
       47,   50,   36,   33,   51,   47,   52,   39,   50,   52,
       39,   44,   72,   75,   51,   79,   78,   79,   98,  100,
      101,  321,  104,   72,   78,  105,  320,  105,   75,   98,
      104,  109,  117,  117,  322,  101,  100,  146,  146,  331,
      109,  319,  317,  315,  322,  314,  313,  311,  309,  331,
      336,  336,  336,  336,  336,  336,  336,  336,  337,  308,
      307,  306,  337,  337,  338,  338,  305,  338,  338,  338,
      338,  338,  339,  339,  339,  339,  340,  340,  340,  340,

      341,  341,  341,  341,  342,  342,  343,  343,  343,  343,
      304,  297,  294,  293,  292,  291,  290,  283,  280,  279,
      278,  277,  275,  273,  272,  270,  269,  268,  267,  266,
      265,  263,  262,  260,  259,  258,  257,  253,  252,  250,
      249,  248,  247,  246,  245,  243,  242,  240,  239,  238,
      237,  234,  233,  232,  231,  230,  229,  227,  226,  225,
      224,  223,  222,  221,  220,  219,  218,  217,  214,  213,
      210,  209,  208,  207,  204,  202,  201,  199,  198,  197,
      196,  195,  194,  193,  192,  191,  190,  189,  186,  185,
      182,  181,  180,  179,  176,  174,  173,  172,  171,  170,

      169,  168,  167,  166,  165,  164,  163,  162,  161,  160,
      159,  158,  157,  156,  154,  152,  151,  150,  149,  148,
      147,  145,  144,  143,  142,  141,  140,  139,  138,  137,
      136,  135,  134,  133,  132,  131,  130,  129,  128,  127,
      125,  123,  122,  121,  120,  119,  118,  116,  115,  114,
      113,  110,  108,  106,  103,  102,   99,   97,   96,   94,
       93,   92,   91,   90,   89,   88,   87,   86,   85,   84,
       83,   82,   80,   77,   76,   73,   71,   70,   68,   67,
       66,   65,   64,   63,   62,   61,   60,   59,   58,   57,
       56,   49,   46,   43,   42,   41,   40,   38,   37,   35,

       30,   29,   27,   26,   25,   24,   22,   21,   19,   14,
       13,   11,   10,    9,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335,  335,  335,  335,  335,  335,
      335,  335,  335,  335,  335
    } ;


/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin = stdin, *yyout = stdout;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;

static char input( void) ;
static void unput( char) ;

char *yytext;
static int yyleng;

/*--------------------------------------------------------------------------*/
/*------------------------- BEGIN LEXICAL ANALYZER -------------------------*/
/*--------------------------------------------------------------------------*/

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;
#ifdef FLEX_REJECT_ENABLED
    int yy_full_match;
#endif




    if ( yy_init )
	{
	YY_INIT;
	yy_start = 1;
	yy_init = 0;
	}

    goto get_next_token;

do_action:

#ifdef FLEX_REJECT_ENABLED
    /* remember matched text in case we back up due to trailing context */
    yy_full_match = yy_c_buf_p;
#endif

    for ( ; ; )
	{
	YY_DO_BEFORE_ACTION

#ifdef FLEX_DEBUG
	fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
	switch ( yy_act )
	    {
case 1:
# line 39 "csubst.l"
{read_comment();}
	YY_BREAK
case 2:
# line 40 "csubst.l"
{default_action();}
	YY_BREAK
case 3:
# line 41 "csubst.l"
{default_action();BEGIN CPP_MACRO;}
	YY_BREAK
case 4:
# line 42 "csubst.l"
{default_action();BEGIN CPP_MACRO;}
	YY_BREAK
case 5:
# line 43 "csubst.l"
{default_action();}
	YY_BREAK
case 6:
# line 44 "csubst.l"
{action_keyword();}
	YY_BREAK
case 7:
# line 45 "csubst.l"
{action_keyword();}
	YY_BREAK
case 8:
# line 46 "csubst.l"
{action_keyword();}
	YY_BREAK
case 9:
# line 47 "csubst.l"
{action_keyword();}
	YY_BREAK
case 10:
# line 48 "csubst.l"
{action_keyword();}
	YY_BREAK
case 11:
# line 49 "csubst.l"
{action_keyword();}
	YY_BREAK
case 12:
# line 50 "csubst.l"
{action_keyword();}
	YY_BREAK
case 13:
# line 51 "csubst.l"
{action_keyword();}
	YY_BREAK
case 14:
# line 52 "csubst.l"
{action_keyword();}
	YY_BREAK
case 15:
# line 53 "csubst.l"
{action_keyword();}
	YY_BREAK
case 16:
# line 54 "csubst.l"
{action_keyword();}
	YY_BREAK
case 17:
# line 55 "csubst.l"
{action_keyword();}
	YY_BREAK
case 18:
# line 56 "csubst.l"
{action_keyword();}
	YY_BREAK
case 19:
# line 57 "csubst.l"
{action_keyword();}
	YY_BREAK
case 20:
# line 58 "csubst.l"
{action_keyword();}
	YY_BREAK
case 21:
# line 59 "csubst.l"
{action_keyword();}
	YY_BREAK
case 22:
# line 60 "csubst.l"
{action_keyword();}
	YY_BREAK
case 23:
# line 61 "csubst.l"
{action_keyword();}
	YY_BREAK
case 24:
# line 62 "csubst.l"
{action_keyword();}
	YY_BREAK
case 25:
# line 63 "csubst.l"
{action_keyword();}
	YY_BREAK
case 26:
# line 64 "csubst.l"
{action_keyword();}
	YY_BREAK
case 27:
# line 65 "csubst.l"
{action_keyword();}
	YY_BREAK
case 28:
# line 66 "csubst.l"
{action_keyword();}
	YY_BREAK
case 29:
# line 67 "csubst.l"
{action_keyword();}
	YY_BREAK
case 30:
# line 68 "csubst.l"
{action_keyword();}
	YY_BREAK
case 31:
# line 69 "csubst.l"
{action_keyword();}
	YY_BREAK
case 32:
# line 70 "csubst.l"
{action_keyword();}
	YY_BREAK
case 33:
# line 71 "csubst.l"
{action_keyword();}
	YY_BREAK
case 34:
# line 72 "csubst.l"
{action_keyword();}
	YY_BREAK
case 35:
# line 73 "csubst.l"
{action_keyword();}
	YY_BREAK
case 36:
# line 74 "csubst.l"
{action_keyword();}
	YY_BREAK
case 37:
# line 75 "csubst.l"
{action_keyword();}
	YY_BREAK
case 38:
# line 76 "csubst.l"
{action_symbol(TYPE_STRING);}
	YY_BREAK
case 39:
# line 77 "csubst.l"
{default_action();}
	YY_BREAK
case 40:
# line 78 "csubst.l"
{action_symbol(TYPE_MACRO);BEGIN 0;}
	YY_BREAK
case 41:
# line 79 "csubst.l"
{action_symbol(TYPE_IDENTIFIER);BEGIN 0;}
	YY_BREAK
case 42:
# line 80 "csubst.l"
{cond_putchar('\n');}
	YY_BREAK
case 43:
# line 81 "csubst.l"
{default_action();}
	YY_BREAK
case 44:
# line 82 "csubst.l"
{default_action();}
	YY_BREAK
case 45:
# line 83 "csubst.l"
YY_DEFAULT_ACTION;
	YY_BREAK

case YY_NEW_FILE:
break; /* begin reading from new file */

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
	    }

get_next_token:
	{
	register int yy_curst;
	register char yy_sym;

	YY_DO_BEFORE_SCAN

	/* set up to begin running DFA */

	yy_curst = yy_start;

	if ( yy_ch_buf[yy_c_buf_p] == '\n' )
	    ++yy_curst;

	/* yy_b_buf_p points to the position in yy_ch_buf
	 * of the start of the current run.
	 */

	yy_b_buf_p = yy_c_buf_p + 1;

	do /* until the machine jams */
	    {
	    if ( yy_c_buf_p == yy_e_buf_p )
		{ /* need more input */
		if ( yy_e_buf_p >= YY_BUF_LIM )
		    { /* not enough room to do another read */
		    /* see if we can make some room for more chars */

		    yy_n_chars = yy_e_buf_p - yy_b_buf_p;

		    if ( yy_n_chars >= 0 )
			/* shift down buffer to make room */
			for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
			    {
			    yy_buf_pos = yy_b_buf_p + yy_iii;
			    yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
			    yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
			    }

		    yy_b_buf_p = 0;
		    yy_e_buf_p = yy_n_chars;

		    if ( yy_e_buf_p >= YY_BUF_LIM )
			YY_FATAL_ERROR( "flex input buffer overflowed" );

		    yy_c_buf_p = yy_e_buf_p;
		    }

		else if ( yy_saw_eof )
		    {
saweof:		    if ( yy_b_buf_p > yy_e_buf_p )
			{
			if ( yywrap() )
			    {
			    yy_act = YY_END_TOK;
			    goto do_action;
			    }
			
			else
			    {
			    YY_INIT;
			    yy_act = YY_NEW_FILE;
			    goto do_action;
			    }
			}

		    else /* do a jam to eat up more input */
			{
#ifndef FLEX_INTERACTIVE_SCANNER
			/* we're going to decrement yy_c_buf_p upon doing
			 * the jam.  In this case, that's wrong, since
			 * it points to the last non-jam character.  So
			 * we increment it now to counter the decrement.
			 */
			++yy_c_buf_p;
#endif
			break;
			}
		    }

		YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
			  YY_MAX_LINE );

		if ( yy_n_chars == YY_NULL )
		    {
		    if ( yy_saw_eof )
	YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
		    yy_saw_eof = 1;
		    goto saweof;
		    }

		yy_e_buf_p += yy_n_chars;
		}

	    ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
	    yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
	    yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

#ifdef FLEX_FULL_TABLE
	    yy_curst = n[yy_curst][yy_sym];

#else /* get next state from compressed table */

	    while ( c[b[yy_curst] + yy_sym] != yy_curst )
		{
		yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
		/* we've arrange it so that templates are never chained
		 * to one another.  This means we can afford make a
		 * very simple test to see if we need to convert to
		 * yy_sym's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		if ( yy_curst >= YY_TEMPLATE )
		    yy_sym = m[yy_sym];
#endif
		}

	    yy_curst = n[b[yy_curst] + yy_sym];

#endif

	    yy_st_buf[yy_c_buf_p] = yy_curst;

	    }
#ifdef FLEX_INTERACTIVE_SCANNER
	while ( b[yy_curst] != YY_JAM_BASE );
#else
	while ( yy_curst != YY_JAM );
	--yy_c_buf_p; /* put back character we jammed on */

#endif

	if ( yy_c_buf_p >= yy_b_buf_p )
	    { /* we matched some text */
	    yy_curst = yy_st_buf[yy_c_buf_p];
	    yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule: /* we branch to this label when doing a REJECT */
#endif

	    for ( ; ; ) /* until we find what rule we matched */
		{
#ifdef FLEX_REJECT_ENABLED
		if ( yy_lp && yy_lp < l[yy_curst + 1] )
		    {
		    yy_act = a[yy_lp];
		    goto do_action; /* "continue 2" */
		    }
#else
		if ( yy_lp )
		    {
		    yy_act = yy_lp;
		    goto do_action; /* "continue 2" */
		    }
#endif

		if ( --yy_c_buf_p < yy_b_buf_p )
		    break;

		yy_curst = yy_st_buf[yy_c_buf_p];
		yy_lp = l[yy_curst];
		}
	    }

	YY_FATAL_ERROR( "no match in flex scanner - possible NULL in input" );
	}
	}

    /*NOTREACHED*/
    }

#ifdef ANSI_C
static  void unput(char c )
#else
static  void unput( c )
char c;
#endif
{
 register int i;
 register int yy_buf_pos ;

    YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */

    if ( yy_c_buf_p == 0 )
	{
    yy_buf_pos = YY_BUF_MAX ;
	for ( i = yy_e_buf_p; i >= yy_c_buf_p; --i )
	    {
	    yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
	    yy_st_buf[yy_buf_pos] = yy_st_buf[i];
	    --yy_buf_pos;
	    }

	yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
	yy_e_buf_p = YY_BUF_MAX;
	}

    if ( yy_c_buf_p <= 0 )
	YY_FATAL_ERROR( "flex scanner push-back overflow" );

    if ( yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n' )
	yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] =  c;

    YY_DO_BEFORE_ACTION; /* set up yytext again */

    }


static char input( void)
{
    char c;

    YY_DO_BEFORE_SCAN

    if ( yy_c_buf_p == yy_e_buf_p )
	{ /* need more input */
	int yy_n_chars;

	/* we can throw away the entire current buffer */
	if ( yy_saw_eof )
	    {
	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;
	    }

	yy_b_buf_p = 0;
	YY_INPUT( yy_ch_buf, yy_n_chars, YY_MAX_LINE );

	if ( yy_n_chars == YY_NULL )
	{
	    yy_saw_eof = 1;

	    if ( yywrap() )
		return ( EOF );

	    YY_INIT;

	    return ( input() );
	}

	yy_c_buf_p = -1;
	yy_e_buf_p = yy_n_chars - 1;
	}

    c = (unsigned char) yy_ch_buf[++yy_c_buf_p];

    YY_DO_BEFORE_ACTION;

    return ( c );
    }

/*--------------------------------------------------------------------------*/
/*------------------------- END OF LEXICAL ANALYZER ------------------------*/
/*--------------------------------------------------------------------------*/

# line 83 "csubst.l"


#ifndef yywrap /* flex defines this as a macro */
/* this is the action yylex() executes on end of file 
   if it returns 0 then processing continues.
 */
yywrap()
{
return (!next_yyin());
}
#endif

void action_symbol(type_flag)
symbol_type_t type_flag;
{ 
extern  char O_string_buffer[];
static int reading_original_string = 1;
char *o_string;

  switch(Mode)
  {
  case PRINT_TRUNCATED:
	if(!symbol_lookup(yytext) && type_flag == TYPE_IDENTIFIER)
  	  printf("%.*s", Truncation, yytext);
	else
	  printf("%s", yytext);
	break;

  case APPLY_SUBSTS:
  o_string =  lookup_subst(yytext);
  if(o_string == NULL)
   printf("%s", yytext);
  else
   printf("%s", o_string);
  break;

  case READ_IGNORES:
  case EXTRACT_SYMBOLS:
    symbol_install(yytext, type_flag);
  break;

  case READ_SUBSTS:
    if(reading_original_string)
      {
      strncpy(O_string_buffer,yytext,SYMBOL_SIZE);
      }
    else
      {
      install_subst(O_string_buffer,yytext);
      }
    reading_original_string = !reading_original_string;
  }

}   


void read_comment()
{
int c, previous;

previous = '*';

if(Mode == APPLY_SUBSTS || Mode == PRINT_TRUNCATED)
   printf("/*");

for(;;){
	c = input();
	if(c == EOF)
	  fatal("EOF in comment");
        else 
	cond_putchar(c);
	if(c == '/'){
	  if(previous == '*')
	    break;
	  }
	previous = c;
	}

}

void default_action()
{
if(Mode == APPLY_SUBSTS || Mode == PRINT_TRUNCATED)
  printf("%s", yytext);
}

void action_keyword()
{
if(Mode == READ_SUBSTS)
  fatal1("Cannot use %s in a replacement", yytext);
if(Mode == APPLY_SUBSTS || Mode == PRINT_TRUNCATED)
   printf("%s", yytext);
}

/* end of file */

