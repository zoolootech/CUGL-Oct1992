#define FLEX_COMPRESSED
/* A lexical scanner generated by flex */

/* scanner skeleton version:
 * $Header: flex.skl,v 2.0.0.1 89/07/30 23:20:47 pcd Exp Locker: pcd $
 */

#include <stdio.h>

#define FLEX_SCANNER

/* define PROTOTYPES */
#if 0
#ifdef __STDC__
#ifndef MWC /* Mark Williams thinks it's __STDC__, how strange
		--HdeF
	    */
#define PROTOTYPES
#endif
#endif
#endif

/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of input buffer */
#endif

/* returned upon end-of-file */
#define YY_END_TOK 0

/* copy whatever the last rule matched to the standard output */

#define ECHO fputs( yytext, yyout )

/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#define YY_INPUT(buf,result,max_size) \
	if ( (result = read( fileno(yyin), buf, max_size )) < 0 ) \
	    YY_FATAL_ERROR( "read() in flex scanner failed" );
#define YY_NULL 0
#define yyterminate() return ( YY_NULL )

/* report a fatal error */
#define YY_FATAL_ERROR(msg) \
	{ \
	fputs( msg, stderr ); \
	putc( '\n', stderr ); \
	exit( 1 ); \
	}

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN yy_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* special action meaning "start processing a new file" */
#define YY_NEW_FILE goto new_file

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */

#ifdef PROTOTYPES
#define YY_DECL int yylex(/* void */ )/*Mark Williams thinks it's standard!! */
#else
#define YY_DECL int yylex()
#endif

/* code executed at the end of each rule */
#define YY_BREAK break;

#define YY_END_OF_BUFFER_CHAR 0

/* done after the current pattern has been matched and before the
 * corresponding action - sets up yytext
 */
#define YY_DO_BEFORE_ACTION \
	yytext = yy_bp; \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

/* returns the length of the matched text */
#define yyleng (yy_cp - yy_bp)

#define EOB_ACT_RESTART_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
	{ \
	*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
	yy_c_buf_p = yy_cp = yy_bp + n; \
	YY_DO_BEFORE_ACTION; /* set up yytext again */ \
	}

#define unput(c) yyunput( c, yy_bp )

#define YY_USER_ACTION

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
char *yytext;

#ifndef PROTOTYPES
#define const
#endif

#define INITIAL 0
/* csubst.l */
/* lex source of csubst utility.
This programme is shareware.
If you found this programme useful then send me a colourful postcard
with the words "Happy Birthday" (or equivalent) so that it arrives
at my address around the first of January 1991.

Henri de Feraudy
27 rue Chef de Ville
92140 Clamart 
France
*/
extern int  Mode, Truncation;
extern char *lookup_subst();
#include <stdio.h>
#include "csubst.h"
#define cond_putchar(C) if(Mode == APPLY_SUBSTS || Mode == PRINT_TRUNCATED)putchar(C);

#ifdef yywrap
#undef yywrap
#define yywrap() (!next_yyin())
#endif

void action_keyword(), default_action(), action_symbol(), read_comment();
#define CPP_MACRO 1
#define YY_END_OF_BUFFER 46
typedef int yy_state_type;
static const short int yy_accept[337] =
    {   0,
        0,    0,    0,    0,   46,   44,   42,   44,   44,   44,
       44,   44,   41,   41,   41,   41,   41,   41,   41,   41,
       41,   41,   41,   41,   41,   41,   41,   41,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,    0,   38,    0,    0,    5,    5,
        5,    0,    0,    1,    0,   41,   41,   41,   41,   41,
       41,   41,   13,   41,   41,   41,   41,   41,   41,   21,
       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
       41,   40,   40,   40,   40,   40,   40,   40,   13,   40,
       40,   40,   40,   40,   40,   21,   40,   40,   40,   40,

       40,   40,   40,   40,   40,   40,   40,    5,    5,    5,
        5,   39,   43,   41,   41,   41,   41,   41,   41,   41,
       41,   41,   41,   41,   19,   41,   22,   41,   41,   41,
       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
       41,   41,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   19,   40,   22,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,    5,    5,    5,    5,    6,   41,    8,    9,   41,
       41,   41,   41,   15,   16,   41,   41,   20,   23,   41,
       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,

       35,   41,   41,    6,   40,    8,    9,   40,   40,   40,
       40,   15,   16,   40,   40,   20,   23,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   35,   40,
       40,    5,    5,    5,    5,    7,   10,   41,   41,   41,
       41,   18,   41,   41,   26,   41,   41,   41,   41,   41,
       41,   33,   41,   41,   37,    7,   10,   40,   40,   40,
       40,   18,   40,   40,   26,   40,   40,   40,   40,   40,
       40,   33,   40,   40,   37,    5,    3,    5,    5,   41,
       41,   14,   17,   41,   25,   27,   28,   29,   30,   31,
       41,   41,   41,   40,   40,   14,   17,   40,   25,   27,

       28,   29,   30,   31,   40,   40,   40,    4,    5,   41,
       12,   41,   32,   41,   41,   40,   12,   40,   32,   40,
       40,    4,    5,   11,   24,   34,   36,   11,   24,   34,
       36,    0,    0,    0,    2,    0
    } ;

static const char yy_ec[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    5,    1,    1,    1,    6,    1,
        1,    7,    1,    1,    1,    8,    9,   10,   11,   11,
       11,   11,   11,   11,   11,   11,   11,    1,    1,   12,
        1,   13,    1,    1,   14,   14,   14,   14,   14,   14,
       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
        1,   16,    1,    1,   17,    1,   18,   19,   20,   21,

       22,   23,   24,   25,   26,   15,   27,   28,   29,   30,
       31,   32,   15,   33,   34,   35,   36,   37,   38,   39,
       40,   41,    1,    1,    1,    1,    1
    } ;

static const char yy_meta[42] =
    {   0,
        1,    2,    1,    1,    1,    3,    1,    4,    4,    5,
        5,    1,    1,    6,    7,    4,    8,    6,    6,    6,
        6,    6,    6,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7
    } ;

static const short int yy_base[345] =
    {   0,
        0,    0,   41,    0,  415,  416,  416,   79,   82,  398,
      406,  373,    0,  375,  377,   67,   65,   58,   62,  378,
       71,  377,  385,   74,  366,  375,  373,  378,    0,  366,
      368,   86,   83,   85,   79,  369,   93,  368,  376,   93,
      357,  366,  364,  369,  116,  416,  390,  100,    0,  370,
       99,  119,  124,  416,    0,    0,  356,  368,  355,  370,
      357,  363,  349,  350,  347,  347,  350,  347,  344,    0,
      343,  347,  109,  345,   65,  116,  349,  342,  111,  110,
      347,    0,  337,  349,  336,  351,  338,  344,  330,  331,
      328,  328,  331,  328,  325,    0,  324,  328,  115,  326,

      116,  123,  330,  323,  117,  120,  328,    0,  330,  131,
      332,  416,  416,  320,  332,  327,  315,  119,  329,  327,
      323,  315,  321,  324,    0,  310,    0,  316,  313,  302,
      304,  306,  313,  299,  297,  297,  309,  299,  303,  307,
      309,  298,  294,  306,  301,  289,  124,  303,  301,  297,
      289,  295,  298,    0,  284,    0,  290,  287,  276,  278,
      280,  287,  273,  271,  271,  283,  273,  277,  281,  283,
      272,  273,  276,  276,  268,    0,  268,    0,    0,  259,
      267,  256,  263,    0,    0,  257,  254,    0,    0,  254,
      254,  251,  263,  253,  257,  262,  261,  259,  249,  254,

        0,  242,  254,    0,  248,    0,    0,  239,  247,  236,
      243,    0,    0,  237,  234,    0,    0,  234,  234,  231,
      243,  233,  237,  242,  241,  239,  229,  234,    0,  222,
      234,  225,  231,  231,  216,    0,    0,  221,  222,  227,
      218,    0,  212,  216,    0,  224,  221,  223,  207,  216,
      218,    0,  209,  212,    0,    0,    0,  207,  208,  213,
      204,    0,  198,  202,    0,  210,  207,  209,  193,  202,
      204,    0,  195,  198,    0,  201,    0,  199,  200,  184,
      184,    0,    0,  196,    0,    0,    0,    0,    0,    0,
      194,  194,  187,  178,  178,    0,    0,  190,    0,    0,

        0,    0,    0,    0,  188,  165,  154,  179,  158,  147,
        0,  135,    0,  146,  144,  142,    0,  130,    0,  141,
      125,  140,  153,    0,    0,    0,    0,    0,    0,    0,
        0,  158,    0,   78,  416,  416,  170,  177,  184,  188,
      192,  196,  200,  203
    } ;

static const short int yy_def[345] =
    {   0,
      336,    1,  336,    3,  336,  336,  336,  337,  338,  339,
      336,  336,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  341,  341,
      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  337,  336,  337,  338,  342,  342,
      342,  339,  339,  336,  343,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  341,  341,  341,  341,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,

      341,  341,  341,  341,  341,  341,  341,  342,  342,  342,
      342,  336,  336,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  341,  341,  341,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
      341,  342,  342,  342,  342,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,

      340,  340,  340,  341,  341,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
      341,  342,  342,  342,  342,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  340,  340,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  341,  341,  341,  341,  341,  341,
      341,  341,  341,  341,  341,  342,  342,  342,  342,  340,
      340,  340,  340,  340,  340,  340,  340,  340,  340,  340,
      340,  340,  340,  341,  341,  341,  341,  341,  341,  341,

      341,  341,  341,  341,  341,  341,  341,  342,  342,  340,
      340,  340,  340,  340,  340,  341,  341,  341,  341,  341,
      341,  336,  342,  340,  340,  340,  340,  341,  341,  341,
      341,  336,  344,  344,  336,    0,  336,  336,  336,  336,
      336,  336,  336,  336
    } ;

static const short int yy_nxt[458] =
    {   0,
        6,    6,    7,    8,    9,   10,    6,    6,   11,   12,
        6,    6,    6,   13,   13,    6,    6,   14,   15,   16,
       17,   18,   19,   20,   13,   21,   13,   22,   13,   13,
       13,   13,   23,   24,   25,   26,   27,   28,   13,   13,
       13,    6,    6,    7,    8,    9,   10,    6,    6,   11,
       12,    6,    6,    6,   29,   29,    6,    6,   30,   31,
       32,   33,   34,   35,   36,   29,   37,   29,   38,   29,
       29,   29,   29,   39,   40,   41,   42,   43,   44,   29,
       29,   29,   46,   48,   59,   64,   62,   65,  132,   67,
      335,   60,   68,   70,   47,   63,   66,   61,   74,   75,

       71,   48,   50,   85,   88,  133,   93,   51,   76,   94,
       86,   77,   90,   89,   91,   96,   87,  100,  101,   46,
       50,  110,   97,   92,  112,   51,  336,  102,  111,   52,
      103,   47,  129,  134,   53,  140,  138,  141,  158,  161,
      163,  322,  167,  130,  139,  169,  331,  170,  135,  159,
      168,  173,  180,  181,  332,  164,  162,  208,  209,  332,
      174,  330,  329,  328,  333,  327,  326,  325,  324,  333,
       45,   45,   45,   45,   45,   45,   45,   45,   49,  323,
      322,  321,   49,   49,   52,   52,  320,   52,   52,   52,
       52,   52,   56,   56,   56,   56,   82,   82,   82,   82,

      108,  108,  108,  108,  113,  113,  334,  334,  334,  334,
      319,  318,  317,  316,  315,  314,  313,  312,  311,  310,
      309,  277,  308,  307,  306,  305,  304,  303,  302,  301,
      300,  299,  298,  297,  296,  295,  294,  293,  292,  291,
      290,  289,  288,  287,  286,  285,  284,  283,  282,  281,
      280,  279,  278,  277,  276,  275,  274,  273,  272,  271,
      270,  269,  268,  267,  266,  265,  264,  263,  262,  261,
      260,  259,  258,  257,  256,  255,  254,  253,  252,  251,
      250,  249,  248,  247,  246,  245,  244,  243,  242,  241,
      240,  239,  238,  237,  236,  235,  234,  233,  232,  231,

      230,  229,  228,  227,  226,  225,  224,  223,  222,  221,
      220,  219,  218,  217,  216,  215,  214,  213,  212,  211,
      210,  207,  206,  205,  204,  203,  202,  201,  200,  199,
      198,  197,  196,  195,  194,  193,  192,  191,  190,  189,
      188,  187,  186,  185,  184,  183,  182,  179,  178,  177,
      176,  175,  172,  171,  166,  165,  160,  157,  156,  155,
      154,  153,  152,  151,  150,  149,  148,  147,  146,  145,
      144,  143,  142,  137,  136,  131,  128,  127,  126,  125,
      124,  123,  122,  121,  120,  119,  118,  117,  116,  115,
      114,  109,  336,  107,  106,  105,  104,   99,   98,   95,

       84,   83,   81,   80,   79,   78,   73,   72,   69,   58,
       57,   55,   54,   53,  336,    5,  336,  336,  336,  336,
      336,  336,  336,  336,  336,  336,  336,  336,  336,  336,
      336,  336,  336,  336,  336,  336,  336,  336,  336,  336,
      336,  336,  336,  336,  336,  336,  336,  336,  336,  336,
      336,  336,  336,  336,  336,  336,  336
    } ;

static const short int yy_chk[458] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    8,    9,   16,   18,   17,   18,   75,   19,
      334,   16,   19,   21,    8,   17,   18,   16,   24,   24,

       21,   48,    9,   32,   33,   75,   35,    9,   24,   35,
       32,   24,   34,   33,   34,   37,   32,   40,   40,   45,
       48,   51,   37,   34,   52,   48,   53,   40,   51,   53,
       40,   45,   73,   76,   52,   80,   79,   80,   99,  101,
      102,  322,  105,   73,   79,  106,  321,  106,   76,   99,
      105,  110,  118,  118,  323,  102,  101,  147,  147,  332,
      110,  320,  318,  316,  323,  315,  314,  312,  310,  332,
      337,  337,  337,  337,  337,  337,  337,  337,  338,  309,
      308,  307,  338,  338,  339,  339,  306,  339,  339,  339,
      339,  339,  340,  340,  340,  340,  341,  341,  341,  341,

      342,  342,  342,  342,  343,  343,  344,  344,  344,  344,
      305,  298,  295,  294,  293,  292,  291,  284,  281,  280,
      279,  278,  276,  274,  273,  271,  270,  269,  268,  267,
      266,  264,  263,  261,  260,  259,  258,  254,  253,  251,
      250,  249,  248,  247,  246,  244,  243,  241,  240,  239,
      238,  235,  234,  233,  232,  231,  230,  228,  227,  226,
      225,  224,  223,  222,  221,  220,  219,  218,  215,  214,
      211,  210,  209,  208,  205,  203,  202,  200,  199,  198,
      197,  196,  195,  194,  193,  192,  191,  190,  187,  186,
      183,  182,  181,  180,  177,  175,  174,  173,  172,  171,

      170,  169,  168,  167,  166,  165,  164,  163,  162,  161,
      160,  159,  158,  157,  155,  153,  152,  151,  150,  149,
      148,  146,  145,  144,  143,  142,  141,  140,  139,  138,
      137,  136,  135,  134,  133,  132,  131,  130,  129,  128,
      126,  124,  123,  122,  121,  120,  119,  117,  116,  115,
      114,  111,  109,  107,  104,  103,  100,   98,   97,   95,
       94,   93,   92,   91,   90,   89,   88,   87,   86,   85,
       84,   83,   81,   78,   77,   74,   72,   71,   69,   68,
       67,   66,   65,   64,   63,   62,   61,   60,   59,   58,
       57,   50,   47,   44,   43,   42,   41,   39,   38,   36,

       31,   30,   28,   27,   26,   25,   23,   22,   20,   15,
       14,   12,   11,   10,    5,  336,  336,  336,  336,  336,
      336,  336,  336,  336,  336,  336,  336,  336,  336,  336,
      336,  336,  336,  336,  336,  336,  336,  336,  336,  336,
      336,  336,  336,  336,  336,  336,  336,  336,  336,  336,
      336,  336,  336,  336,  336,  336,  336
    } ;

/* the intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static char *yy_c_buf_p;	/* points to current character in buffer */
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */
#ifndef ORIGINAL
static char *yy_cp, *yy_bp;
#endif

/* true when we've seen an EOF for the current input file */
static int yy_eof_has_been_seen;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */

/* yy_ch_buf has to be 2 characters longer than YY_BUF_SIZE because we need
 * to put in 2 end-of-buffer characters (this is explained where it is
 * done) at the end of yy_ch_buf
 */
static char yy_ch_buf[YY_BUF_SIZE + 2];

/* yy_hold_char holds the character lost when yytext is formed */
static char yy_hold_char;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

#ifdef PROTOTYPES
static yy_state_type yy_get_previous_state( void );
static int yy_get_next_buffer( void );
static void yyunput( int c, char *buf_ptr );
static int input( void );
static void yyrestart( FILE *input_file );
#else
static yy_state_type yy_get_previous_state();
static int yy_get_next_buffer();
static void yyunput();
static int input();
static void yyrestart();
#endif

YY_DECL
    {
    register yy_state_type yy_current_state;
#ifdef ORIGINAL
    register char *yy_cp, *yy_bp;
#endif
    register int yy_act;




    if ( yy_init )
	{
	if ( ! yy_start )
	    yy_start = 1;	/* first start state */

	if ( ! yyin )
	    yyin = stdin;

	if ( ! yyout )
	    yyout = stdout;

new_file:
	/* this is where we enter upon encountering an end-of-file and
	 * yywrap() indicating that we should continue processing
	 */

	/* we put in the '\n' and start reading from [1] so that an
	 * initial match-at-newline will be true.
	 */

	yy_ch_buf[0] = '\n';
	yy_n_chars = 1;

	/* we always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yy_eof_has_been_seen = 0;

	yytext = yy_c_buf_p = &yy_ch_buf[1];
	yy_hold_char = *yy_c_buf_p;
	yy_init = 0;
	}

    while ( 1 )		/* loops until end-of-file is reached */
	{
	yy_cp = yy_c_buf_p;

	/* support of yytext */
	*yy_cp = yy_hold_char;

	/* yy_bp points to the position in yy_ch_buf of the start of the
	 * current run.
	 */
	yy_bp = yy_cp;

	yy_current_state = yy_start;
	do
	    {
	    register char yy_c = yy_ec[*yy_cp];
	    if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = yy_def[yy_current_state];
		if ( yy_current_state >= 337 )
		    yy_c = yy_meta[yy_c];
		}
	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	    ++yy_cp;
	    }
	while ( yy_current_state != 336 );
	yy_cp = yy_last_accepting_cpos;
	yy_current_state = yy_last_accepting_state;

	/* bogus while loop to let YY_BACK_TRACK, EOB_ACT_LAST_MATCH,
	 * and EOF actions branch here without introducing an optimizer-
	 * daunting goto
	 */
	while ( 1 )
	    {
	    yy_act = yy_accept[yy_current_state];

	    YY_DO_BEFORE_ACTION;
	    YY_USER_ACTION;

#ifdef FLEX_DEBUG
	    fprintf( stderr, "--accepting rule #%d (\"%s\")\n",
		     yy_act, yytext );
#endif

do_action:	/* this label is used only to access EOF actions */
	    switch ( yy_act )
		{
		case 0: /* must backtrack */
		/* undo the effects of YY_DO_BEFORE_ACTION */
		*yy_cp = yy_hold_char;
		yy_cp = yy_last_accepting_cpos;
		yy_current_state = yy_last_accepting_state;
		continue; /* go to "YY_DO_BEFORE_ACTION" */

case 1:
{read_comment();}
	YY_BREAK
case 2:
{default_action();}
	YY_BREAK
case 3:
{default_action();BEGIN CPP_MACRO;}
	YY_BREAK
case 4:
{default_action();BEGIN CPP_MACRO;}
	YY_BREAK
case 5:
{default_action();}
	YY_BREAK
case 6:
{action_keyword();}
	YY_BREAK
case 7:
{action_keyword();}
	YY_BREAK
case 8:
{action_keyword();}
	YY_BREAK
case 9:
{action_keyword();}
	YY_BREAK
case 10:
{action_keyword();}
	YY_BREAK
case 11:
{action_keyword();}
	YY_BREAK
case 12:
{action_keyword();}
	YY_BREAK
case 13:
{action_keyword();}
	YY_BREAK
case 14:
{action_keyword();}
	YY_BREAK
case 15:
{action_keyword();}
	YY_BREAK
case 16:
{action_keyword();}
	YY_BREAK
case 17:
{action_keyword();}
	YY_BREAK
case 18:
{action_keyword();}
	YY_BREAK
case 19:
{action_keyword();}
	YY_BREAK
case 20:
{action_keyword();}
	YY_BREAK
case 21:
{action_keyword();}
	YY_BREAK
case 22:
{action_keyword();}
	YY_BREAK
case 23:
{action_keyword();}
	YY_BREAK
case 24:
{action_keyword();}
	YY_BREAK
case 25:
{action_keyword();}
	YY_BREAK
case 26:
{action_keyword();}
	YY_BREAK
case 27:
{action_keyword();}
	YY_BREAK
case 28:
{action_keyword();}
	YY_BREAK
case 29:
{action_keyword();}
	YY_BREAK
case 30:
{action_keyword();}
	YY_BREAK
case 31:
{action_keyword();}
	YY_BREAK
case 32:
{action_keyword();}
	YY_BREAK
case 33:
{action_keyword();}
	YY_BREAK
case 34:
{action_keyword();}
	YY_BREAK
case 35:
{action_keyword();}
	YY_BREAK
case 36:
{action_keyword();}
	YY_BREAK
case 37:
{action_keyword();}
	YY_BREAK
case 38:
{action_symbol(TYPE_STRING);}
	YY_BREAK
case 39:
{default_action();}
	YY_BREAK
case 40:
{action_symbol(TYPE_MACRO);BEGIN 0;}
	YY_BREAK
case 41:
{action_symbol(TYPE_IDENTIFIER);BEGIN 0;}
	YY_BREAK
case 42:
{cond_putchar('\n');}
	YY_BREAK
case 43:
{default_action();}
	YY_BREAK
case 44:
{default_action();}
	YY_BREAK
case 45:
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(CPP_MACRO):
    yyterminate();

		case YY_END_OF_BUFFER:
		    /* undo the effects of YY_DO_BEFORE_ACTION */
		    *yy_cp = yy_hold_char;

		    yytext = yy_bp;

		    switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
			    {
			    if ( yywrap() )
				{
				/* note: because we've taken care in
				 * yy_get_next_buffer() to have set up yytext,
				 * we can now set up yy_c_buf_p so that if some
				 * total hoser (like flex itself) wants
				 * to call the scanner after we return the
				 * YY_NULL, it'll still work - another YY_NULL
				 * will get returned.
				 */
				yy_c_buf_p = yytext;

				yy_act = YY_STATE_EOF((yy_start - 1) / 2);
				goto do_action;
				}

			    else
				YY_NEW_FILE;
			    }
			    break;

			case EOB_ACT_RESTART_SCAN:
			    yy_c_buf_p = yytext;
			    yy_hold_char = *yy_c_buf_p;
			    break;

			case EOB_ACT_LAST_MATCH:
			    yy_c_buf_p = &yy_ch_buf[yy_n_chars];

			    yy_current_state = yy_get_previous_state();

			    yy_cp = yy_c_buf_p;
			    yy_bp = yytext;
			    continue; /* go to "YY_DO_BEFORE_ACTION" */
			}
		    break;

		default:
		    printf( "action # %d\n", yy_act );
		    YY_FATAL_ERROR( "fatal flex scanner internal error" );
		}

	    break; /* exit bogus while loop */
	    }
	}
    }


/* yy_get_next_buffer - try to read in new buffer
 *
 * synopsis
 *     int yy_get_next_buffer();
 *     
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH - 
 *     EOB_ACT_RESTART_SCAN - restart the scanner
 *     EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()

    {
    register char *dest = yy_ch_buf;
    register char *source = yytext - 1; /* copy prev. char, too */
    register int number_to_move, i;
    int ret_val;
    
    if ( yy_c_buf_p != &yy_ch_buf[yy_n_chars + 1] )
	{
	YY_FATAL_ERROR( "NULL in input" );
	/*NOTREACHED*/
	}

    /* try to read more data */

    /* first move last chars to start of buffer */
    number_to_move = yy_c_buf_p - yytext;

    for ( i = 0; i < number_to_move; ++i )
	*(dest++) = *(source++);

    if ( yy_eof_has_been_seen )
	/* don't do the read, it's not guaranteed to return an EOF,
	 * just force an EOF
	 */
	yy_n_chars = 0;

    else
	{
	int num_to_read = YY_BUF_SIZE - number_to_move - 1;

	if ( num_to_read > YY_READ_BUF_SIZE )
	    num_to_read = YY_READ_BUF_SIZE;

	/* read in more data */
	YY_INPUT( (&yy_ch_buf[number_to_move]), yy_n_chars, num_to_read );
	}

    if ( yy_n_chars == 0 )
	{
	if ( number_to_move == 1 )
	    ret_val = EOB_ACT_END_OF_FILE;
	else
	    ret_val = EOB_ACT_LAST_MATCH;

	yy_eof_has_been_seen = 1;
	}

    else
	ret_val = EOB_ACT_RESTART_SCAN;

    yy_n_chars += number_to_move;
    yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    /* yytext begins at the second character in
     * yy_ch_buf; the first character is the one which
     * preceded it before reading in the latest buffer;
     * it needs to be kept around in case it's a
     * newline, so yy_get_previous_state() will have
     * with '^' rules active
     */

    yytext = &yy_ch_buf[1];

    return ( ret_val );
    }


/* yy_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     yy_state_type yy_get_previous_state();
 */

static yy_state_type yy_get_previous_state()

    {
    register yy_state_type yy_current_state;
    register char *yy_cp;

    yy_current_state = yy_start;

    for ( yy_cp = yytext; yy_cp < yy_c_buf_p; ++yy_cp )
	{
	register char yy_c = yy_ec[*yy_cp];
	if ( yy_accept[yy_current_state] )
	    {
	    yy_last_accepting_state = yy_current_state;
	    yy_last_accepting_cpos = yy_cp;
	    }
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
	    {
	    yy_current_state = yy_def[yy_current_state];
	    if ( yy_current_state >= 337 )
		yy_c = yy_meta[yy_c];
	    }
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	}

    return ( yy_current_state );
    }


#ifdef PROTOTYPES
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif

    {
    register char *yy_cp = yy_c_buf_p;

    *yy_cp = yy_hold_char; /* undo effects of setting up yytext */

    if ( yy_cp < yy_ch_buf + 2 )
	{ /* need to shift things up to make room */
	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
	register char *dest = &yy_ch_buf[YY_BUF_SIZE + 2];
	register char *source = &yy_ch_buf[number_to_move];

	while ( source > yy_ch_buf )
	    *--dest = *--source;

	yy_cp += dest - source;
	yy_bp += dest - source;
	yy_n_chars += dest - source;

	if ( yy_cp < yy_ch_buf + 2 )
	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
	}

    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
	yy_cp[-2] = '\n';

    *--yy_cp = c;

    YY_DO_BEFORE_ACTION; /* set up yytext again */
    }


static int input()

    {
    int c;
    char *yy_cp = yy_c_buf_p;

    *yy_cp = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
	{ /* need more input */
	yytext = yy_c_buf_p;
	++yy_c_buf_p;

	switch ( yy_get_next_buffer() )
	    {
	    /* this code, unfortunately, is somewhat redundant with
	     * that above
	     */
	    case EOB_ACT_END_OF_FILE:
		{
		if ( yywrap() )
		    {
		    yy_c_buf_p = yytext;
		    return ( EOF );
		    }

		yy_ch_buf[0] = '\n';
		yy_n_chars = 1;
		yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
		yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
		yy_eof_has_been_seen = 0;
		yytext = yy_c_buf_p = &yy_ch_buf[1];
		yy_hold_char = *yy_c_buf_p;

		return ( input() );
		}
		break;

	    case EOB_ACT_RESTART_SCAN:
		yy_c_buf_p = yytext;
		break;

	    case EOB_ACT_LAST_MATCH:
		YY_FATAL_ERROR( "unexpected last match in input()" );
	    }
	}

    c = *yy_c_buf_p;
    yy_hold_char = *++yy_c_buf_p;

    return ( c );
    }


#ifdef PROTOTYPES
static void yyrestart( FILE *input_file )
#else
static void yyrestart( input_file )
FILE *input_file;
#endif

    {
    if ( yyin != stdin )
	fclose( yyin );

    yyin = input_file;
    yy_init = 1;
    }


#ifndef yywrap /* flex defines this as a macro */
/* this is the action yylex() executes on end of file 
   if it returns 0 then processing continues.
 */
yywrap()
{
return (!next_yyin());
}
#endif

void action_symbol(type_flag)
symbol_type_t type_flag;
{ 
extern  char O_string_buffer[];
static int reading_original_string = 1;
char *o_string;

  switch(Mode)
  {
  case PRINT_TRUNCATED:
	if(!symbol_lookup(yytext) && type_flag == TYPE_IDENTIFIER)
  	  printf("%.*s", Truncation, yytext);
	else
	  printf("%s", yytext);
	break;

  case APPLY_SUBSTS:
  o_string =  lookup_subst(yytext);
  if(o_string == NULL)
   printf("%s", yytext);
  else
   printf("%s", o_string);
  break;

  case READ_IGNORES:
  case EXTRACT_SYMBOLS:
    symbol_install(yytext, type_flag);
  break;

  case READ_SUBSTS:
    if(reading_original_string)
      {
      strncpy(O_string_buffer,yytext,SYMBOL_SIZE);
      }
    else
      {
      install_subst(O_string_buffer,yytext);
      }
    reading_original_string = !reading_original_string;
  }

}   


void read_comment()
{
int c, previous;

previous = '*';

if(Mode == APPLY_SUBSTS || Mode == PRINT_TRUNCATED)
   printf("/*");

for(;;){
	c = input();
	if(c == EOF)
	  fatal("EOF in comment");
        else 
	cond_putchar(c);
	if(c == '/'){
	  if(previous == '*')
	    break;
	  }
	previous = c;
	}

}

void default_action()
{
if(Mode == APPLY_SUBSTS || Mode == PRINT_TRUNCATED)
  printf("%s", yytext);
}

void action_keyword()
{
if(Mode == READ_SUBSTS)
  fatal1("Cannot use %s in a replacement", yytext);
if(Mode == APPLY_SUBSTS || Mode == PRINT_TRUNCATED)
   printf("%s", yytext);
}

/* end of file */

